var X=Object.defineProperty;var Y=(d,e,t)=>e in d?X(d,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[e]=t;var v=(d,e,t)=>(Y(d,typeof e!="symbol"?e+"":e,t),t);import{b5 as D,e as F,k as R,f as b,l as C,az as G,b6 as U,o as S,c as B,d as T,E as J,u as K,h as Q,n as Z,b7 as tt,A as et,p as st,b as nt}from"./vendor.25aa5a2e.js";import{_ as it}from"./index.ecdfde13.js";const{cos:L}=Math,{max:j}=Math,{sin:E}=Math,{sqrt:V}=Math,{pow:ft}=Math,{floor:W}=Math,{ceil:ot}=Math,f=Math.PI,z=d=>d**2,q=d=>{const e=d.radius,t=100,s=100,n=D();return n.arc(t,s,e,d.start,d.end,!1),n.toString()},at=([,d],e)=>{var p,m,h,x,g;const t=[],s=d.radius,o=125*360/(2*f*s||10),i=(90-o)*f/180,a=(90+o)*f/180;let l=((p=d.positions.get(d.positions.size-1))==null?void 0:p.radian)||0;for(const[,_]of d.positions){const w=[..._.nodes.values()],y=(g=(x=(h=(m=w==null?void 0:w[0])==null?void 0:m.data)==null?void 0:h.state)==null?void 0:x.type)==null?void 0:g.toLowerCase();s==0?t.push({start:115*f/180,end:65*f/180,radius:e/4,state:y||null}):_.radian>i&&l<a?(t.push({start:l,end:i,radius:s,state:null}),t.push({start:a,end:_.radian,radius:s,state:y||null})):t.push({start:l,end:_.radian,radius:s,state:y||null}),l=_.radian}return t};const rt=d=>(st("data-v-07d676a7"),d=d(),nt(),d),dt=rt(()=>T("g",{class:"mini-radar__ring-container"},null,-1)),ct=[dt],lt=F({props:{radar:null,collapsedTrees:null,transform:{default:()=>({x:0,y:0,k:1})},height:null,width:null,id:null,baseRadius:{default:300},disableInteractions:{type:Boolean,default:!1},hideViewport:{type:Boolean,default:!1}},emits:["drag-viewport","pan-to-location"],setup(d,{emit:e}){const t=d,s=R(),n=R(),o=R(),i=R(),a=R(0),l=R(0),p=R(!1),m=b(()=>{var c;const u=[...((c=t.collapsedTrees)==null?void 0:c.entries())||new Map().entries()];return new Map([...t.radar.nodes.entries()].filter(([,r])=>u.every(([,M])=>!M.get(r.id))).filter(([,r])=>{var A;if(!t.radar.rings.get(r.ring))return;const{position:P}=r;if(!P)return;const k=[...P.nodes.values()];return((A=k==null?void 0:k[0])==null?void 0:A.id)==r.id}))}),h=b(()=>{const u=new Set([...m.value.entries()].map(([,c])=>c.ring));return new Map([...t.radar.rings.entries()].filter(([c])=>u.has(c)))}),x=b(()=>{const u=[...h.value.entries()].map(([,c])=>c.radius);return Math.max(...u,t.baseRadius*2)}),g=b(()=>Math.min(l.value,a.value)/(x.value*2.5)),_=b(()=>({height:`${w.value.height}px`,width:`${w.value.width}px`})),w=b(()=>!t.height||!t.width?{height:0,width:0}:{height:t.height*g.value,width:t.width*g.value}),y=()=>{var c;const u=r=>`radar__arc-segment ${r.state?`${r.state}-stroke`:""}`;(c=i.value)==null||c.style("transform",`scale(${g.value})`).selectAll(".radar__arc-segment-group").data(h.value).join(r=>r.append("g").attr("class","radar__arc-segment-group"),r=>r,r=>r.remove()).selectAll(".radar__arc-segment").data(r=>at(r,t.baseRadius)).join(r=>r.append("path").attr("class",u).attr("fill","transparent").attr("stroke","rgba(0, 0, 0, 0.1)").attr("stroke-width",80).attr("d",M=>q(M)),r=>r.attr("class",u).attr("d",M=>q(M)),r=>r.remove())},I=u=>{if(!p.value||t.disableInteractions)return;const c=u.movementX*-(1/g.value),r=u.movementY*-(1/g.value);e("drag-viewport",{x:c,y:r})},N=u=>{var k;if(t.disableInteractions)return;const c=(k=u.target)==null?void 0:k.getBoundingClientRect(),r=(u.clientX-c.left-100)/g.value,M=(u.clientY-c.top-100)/g.value,P=tt.scale(t.transform.k).translate(-r,-M);e("pan-to-location",P)},$=()=>{var r;if(!s.value)return;const u=s.value.offsetWidth,c=s.value.offsetHeight;l.value=u,a.value=c,(r=o.value)==null||r.attr("viewbox","0, 0, 200, 200").attr("width",u).attr("height",c),y()};C(()=>t.transform,()=>{if(n.value){const u=(1-t.transform.x/t.transform.k)*g.value+100-w.value.width/2,c=(1-t.transform.y/t.transform.k)*g.value+100-w.value.height/2;n.value.style.transform=`translate(${u}px, ${c}px) scale(${1/t.transform.k})`,n.value.style.borderRadius=`${Math.max(4*t.transform.k,4)}px`}}),C(h,()=>requestAnimationFrame(()=>y()));const O=()=>{o.value=et(".mini-radar__canvas"),i.value=o.value.select(".mini-radar__ring-container"),i.value.style("transform",`scale(${g.value})`),$(),y()};return G(()=>{O(),window.addEventListener("resize",$)}),U(()=>{window.removeEventListener("resize",$)}),(u,c)=>(S(),B("div",{ref_key:"container",ref:s,class:Z(["mini-radar position-relative",{"mini-radar--disabled":t.disableInteractions}]),onMousemove:I,onMouseleave:c[2]||(c[2]=r=>p.value=!1)},[T("svg",{class:"mini-radar__canvas",onClick:N},ct),d.hideViewport?Q("",!0):(S(),B("div",{key:0,ref_key:"viewport",ref:n,class:"mini-radar__viewport position-absolute",style:J(K(_)),onMousedown:c[0]||(c[0]=r=>p.value=!0),onMouseup:c[1]||(c[1]=r=>p.value=!1)},null,36))],34))}});var vt=it(lt,[["__scopeId","data-v-07d676a7"]]);function H(d){return Array.from(d).filter(([,e])=>e.nodes.size==0)}function ut(d){var t;return(t=H(d)[0])==null?void 0:t[0]}class mt{constructor(){v(this,"_id","id");v(this,"_dependencies","upstream_ids");v(this,"nodes",new Map);v(this,"positions",new Map);v(this,"links",[]);v(this,"rings",new Map);v(this,"expandedRings",[]);v(this,"baseRadius",500);v(this,"channelWidth",250);v(this,"width",275);v(this,"height",145);v(this,"cx",0);v(this,"cy",0);return this}center([e,t]){return this.cx=e,this.cy=t,this}expandRing(e){if(!this.rings.get(e))throw new Error("Invalid ringId when expanding ring.");if(this.expandedRings.includes(e))throw new Error("Attempted to expand an already expanded ring.");return this.expandedRings.push(e),this.computeRings(),this.computeInitialPositions(),this}collapseRing(e){if(!this.rings.get(e))throw new Error("Invalid ringId when collapsing ring.");const s=this.expandedRings.indexOf(e);if(s==-1)throw new Error("Attempted to collapse an already collapsed ring.");return this.expandedRings.splice(s,1),this.computeRings(),this.computeInitialPositions(),this}id(e){return this._id=e,this}dependencies(e){return this._dependencies=e,this}items(e){return this.update(e),this}traverse(e,t){if(!e)throw new Error("No starting node was provided to the traverse method.");const s=[e];let n;const o=new Map;for(;s.length>0;)if(n=s.shift(),t==null||t(n),!!n.downstreamNodes.size)for(const[i,a]of n.downstreamNodes)s.push(a),o.set(i,n);return o}update(e){this.nodes=new Map,this.rings=new Map,this.links=[],this.computeNodes(e),this.computeLinks(),this.computeNodeRings(),this.computeRings(),this.computeInitialPositions()}computeNodes(e){const t=e.length;for(let s=0;s<t;s++){const n=e[s],o=this.nodes.get(n[this._id]);o?this.nodes.set(n[this._id],{id:n[this._id],cx:o.cx,cy:o.cy,radian:o.radian,data:n,downstreamNodes:new Map,upstreamNodes:new Map,ring:o.ring}):this.nodes.set(n[this._id],{id:n[this._id],cx:0,cy:0,radian:0,data:n,downstreamNodes:new Map,upstreamNodes:new Map,ring:0})}}computeNodeRings(){const e=[...this.rings.entries()];for(const[t,s]of this.nodes){const n=this.distance(s,"up");s.ring=n,this.nodes.set(t,s),e[n]?e[n][1].nodes.set(t,s):e[n]=[n,{radius:0,nodes:new Map([[t,s]]),positions:new Map,links:[]}]}this.rings=new Map(e)}computeLinks(){for(const[e,t]of this.nodes){const s=t.data[this._dependencies],n=s.length;for(let o=0;o<n;o++){const i=this.nodes.get(s[o][this._id]),a={target:t,source:i};t.upstreamNodes.set(s[o][this._id],i),i.downstreamNodes.set(e,t),this.nodes.set(s[o][this._id],i),this.nodes.set(e,t),this.links.push(a)}}}distance(e,t){const s=t=="up"?"upstreamNodes":t=="down"?"downstreamNodes":void 0;if(s==null)throw new Error("Direction wasn't provided; accepted values: 'up' or 'down'.");const n=(o,i=0)=>{if(o[s].size>0){const a=[];i=i+1;for(const[,l]of o[s]){const p=n(l,i);a.push(p)}return j(...a)}return i};return n(e)}computeRings(e=0){var s;const t=[...this.rings.entries()];for(let n=e;n<t.length;n++){const o=t[0][1].nodes.size,{size:i}=t[n][1].nodes,a=(s=t[n-1])==null?void 0:s[1];let l;if(a?l=a.radius+this.baseRadius:l=o===1?n*this.baseRadius:(n+1)*this.baseRadius,this.expandedRings.includes(n)&&i>1){const m=V(z(this.height)+z(this.width));l=j(ot(i*m/(f*2)),l)}const p=this.computeRingPositions(l);t[n][1].radius=l,t[n][1].positions=p;for(let m=0;m<p.size;m++){const h=p.get(m);!h||this.positions.set(h.id,h)}}this.rings=new Map(t),this.links.forEach(n=>{const o=this.rings.get(n.source.ring);o&&(o.links.push(n),this.rings.set(n.source.ring,o))})}computeInitialPositions(){if(this.rings.size===0)return;let e;for(const[t,s]of this.rings){let n=0;for(const[o,i]of s.nodes){const a=this.getNodePosition(i,t,e,n);i.cx=this.cx+s.radius*L(a.radian),i.cy=this.cy+s.radius*E(a.radian),i.radian=a.radian,i.position=a,a.nodes.set(i.id,i),s.positions.set(a.id,a),this.rings.set(t,s),this.nodes.set(o,i),++n}e=s}this.nodes=new Map([...this.nodes].sort(([,t],[,s])=>!t.position||!s.position?0:t.ring==s.ring?t.position.id-s.position.id:t.ring-s.ring))}computeRingPositions(e){const t=new Map;if(e<=0)return t.set(0,{id:0,radian:0,nodes:new Map,radius:e}),t;let s=0,n=0;const o=[0],i=f/2-this.width*.8/2/e;for(;s<i;){const a=1.25-.3*E(s),l=V(z(this.height)*z(L(n))+z(this.width)*z(E(n))),p=a*l/e;n+=p,s+=p,s<i&&(s<e/(this.channelWidth+this.width/2)&&(o.push(s%(2*f)),o.push((3*f-s)%(2*f))),o.push((f+s)%(2*f)),o.push((2*f-s)%(2*f)))}return o.push(f),o.sort().forEach((a,l)=>t.set(l,{id:l,radian:a,nodes:new Map,radius:e})),t}getNodePosition(e,t,s,n=0){var p,m;const i=this.rings.get(t).positions;let a;if([...i.values()].every(h=>h.nodes.size>0))return i.get(i.size-1);if(e.upstreamNodes.size===0||t==0||t==1){const h=H(i);n===0||n%2===0?a=i.get((p=h[0])==null?void 0:p[0]):a=i.get((m=h[W(h.length/2)])==null?void 0:m[0])}else{const h=e.upstreamNodes.entries();for(;!a;){const[,x]=h.next().value||[null,null];if(!x)break;const g=W(x.position/s.positions.size*i.size),_=i.get(g);if(_&&_.nodes.size===0){a=_;break}let w=g-1==0?i.size-1:g-1,y=g+1;for(;w>=0||y<=i.size;){const I=i.get(w);if(I&&I.nodes.size===0){a=I;break}const N=i.get(y);if(N&&N.nodes.size===0){a=N;break}w--,y++}}}if(!a){const h=ut(i);a=typeof h!="undefined"?i.get(h):i.get(i.size-1)}return a}}export{vt as M,mt as R,f as a,E as b,L as c,ft as p,V as s};
