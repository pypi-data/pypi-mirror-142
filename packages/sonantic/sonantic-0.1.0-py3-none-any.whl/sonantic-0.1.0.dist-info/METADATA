Metadata-Version: 2.1
Name: sonantic
Version: 0.1.0
Summary: Python client for the Sonantic API
Home-page: https://github.com/sonantic-samples/sonantic-python
Author: Sonantic
Author-email: support@sonantic.io
License: MIT
Platform: UNKNOWN
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: requests
Requires-Dist: pydantic
Provides-Extra: all
Requires-Dist: requests ; extra == 'all'
Requires-Dist: pydantic ; extra == 'all'
Requires-Dist: pytest ; extra == 'all'
Requires-Dist: black ; extra == 'all'
Requires-Dist: isort ; extra == 'all'
Requires-Dist: pre-commit ; extra == 'all'
Requires-Dist: build ; extra == 'all'
Requires-Dist: twine ; extra == 'all'
Provides-Extra: dev
Requires-Dist: black ; extra == 'dev'
Requires-Dist: isort ; extra == 'dev'
Requires-Dist: pre-commit ; extra == 'dev'
Requires-Dist: build ; extra == 'dev'
Requires-Dist: twine ; extra == 'dev'
Provides-Extra: test
Requires-Dist: pytest ; extra == 'test'

# Sonantic Python Library

[![CI](https://github.com/sonantic/sonantic-python/actions/workflows/ci.yaml/badge.svg)](https://github.com/sonantic/sonantic-python/actions/workflows/ci.yaml)

Interact with the Sonantic API from Python.

## Installation

You can install `sonantic` from PyPI

```sh
pip install sonantic
```

## Example

You will need to set your API key which can be found in your [Sonantic Dashboard](https://app.sonantic.io/developers)

```python
import sonantic
from sonantic.core import Error

# make sure to set the API key before you call any methods
sonantic.api_key = "live_c..."

# list available voices
voices = sonantic.voices.list()


print("Available voices")
for voice in voices.items:
    print(f"\t{voice.name}")

print()
print("Creating speech...")

speech = sonantic.speech.create(
    voice="taylor", text="The quick brown fox jumps over the lazy dog."
)

# check the request was successful and handle the error otherwise
if isinstance(speech, Speech):
    path = f"./{speech.id}.wav"
    print(f"Saving audio to file {path}")
    # store generated speech - the audio is decoded by default
    with open(path, "bx") as f:
        f.write(speech.audio.content)
else:
    # handle the error
    print(speech.error)
    print(speech.message)
```


