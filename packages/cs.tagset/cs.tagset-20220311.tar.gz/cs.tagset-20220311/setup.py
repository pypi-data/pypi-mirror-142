#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.tagset',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20220311',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  description =
    ('Tags and sets of tags     with __format__ support and optional ontology '    
 'information.'),
  long_description =
    ('Tags and sets of tags\n'    
 '    with __format__ support and optional ontology information.\n'    
 '\n'    
 '*Latest release 20220311*:\n'    
 'Assorted internal changes.\n'    
 '\n'    
 '    See `cs.fstags` for support for applying these to filesystem objects\n'    
 '    such as directories and files.\n'    
 '\n'    
 '    See `cs.sqltags` for support for databases of entities with tags,\n'    
 '    not directly associated with filesystem objects.\n'    
 '    This is suited to both log entries (entities with no "name")\n'    
 '    and large collections of named entities;\n'    
 '    both accept `Tag`s and can be searched on that basis.\n'    
 '\n'    
 '    All of the available complexity is optional:\n'    
 '    you can use `Tag`s without bothering with `TagSet`s\n'    
 '    or `TagsOntology`s.\n'    
 '\n'    
 '    This module contains the following main classes:\n'    
 '    * `Tag`: an object with a `.name` and optional `.value` (default '    
 '`None`)\n'    
 '      and also an optional reference `.ontology`\n'    
 '      for associating semantics with tag values.\n'    
 '      The `.value`, if not `None`, will often be a string,\n'    
 '      but may be any Python object.\n'    
 "      If you're using these via `cs.fstags`,\n"    
 '      the object will need to be JSON transcribeable.\n'    
 '    * `TagSet`: a `dict` subclass representing a set of `Tag`s\n'    
 '      to associate with something;\n'    
 '      it also has setlike `.add` and `.discard` methods.\n'    
 '      As such it only supports a single `Tag` for a given tag name,\n'    
 '      but that tag value can of course be a sequence or mapping\n'    
 '      for more elaborate tag values.\n'    
 '    * `TagsOntology`:\n'    
 '      a mapping of type names to `TagSet`s defining the type\n'    
 '      and also to entries for the metadata for specific per-type values.\n'    
 '\n'    
 "    Here's a simple example with some `Tag`s and a `TagSet`.\n"    
 '\n'    
 '        >>> tags = TagSet()\n'    
 '        >>> # add a "bare" Tag named \'blue\' with no value\n'    
 "        >>> tags.add('blue')\n"    
 '        >>> # add a "topic=tagging" Tag\n'    
 "        >>> tags.set('topic', 'tagging')\n"    
 '        >>> # make a "subtopic" Tag and add it\n'    
 "        >>> subtopic = Tag('subtopic', 'ontologies')\n"    
 '        >>> tags.add(subtopic)\n'    
 '        >>> # Tags have nice repr() and str()\n'    
 '        >>> subtopic\n'    
 "        Tag(name='subtopic',value='ontologies')\n"    
 '        >>> print(subtopic)\n'    
 '        subtopic=ontologies\n'    
 '        >>> # a TagSet also has a nice repr() and str()\n'    
 '        >>> tags\n'    
 "        TagSet:{'blue': None, 'topic': 'tagging', 'subtopic': 'ontologies'}\n"    
 '        >>> print(tags)\n'    
 '        blue subtopic=ontologies topic=tagging\n'    
 "        >>> tags2 = TagSet({'a': 1}, b=3, c=[1,2,3], d='dee')\n"    
 '        >>> tags2\n'    
 "        TagSet:{'a': 1, 'b': 3, 'c': [1, 2, 3], 'd': 'dee'}\n"    
 '        >>> print(tags2)\n'    
 '        a=1 b=3 c=[1,2,3] d=dee\n'    
 '        >>> # since you can print a TagSet to a file as a line of text\n'    
 '        >>> # you can get it back from a line of text\n'    
 "        >>> TagSet.from_line('a=1 b=3 c=[1,2,3] d=dee')\n"    
 "        TagSet:{'a': 1, 'b': 3, 'c': [1, 2, 3], 'd': 'dee'}\n"    
 '        >>> # because TagSets are dicts you can format strings with them\n'    
 "        >>> print('topic:{topic} subtopic:{subtopic}'.format_map(tags))\n"    
 '        topic:tagging subtopic:ontologies\n'    
 '        >>> # TagSets have convenient membership tests\n'    
 '        >>> # test for blueness\n'    
 "        >>> 'blue' in tags\n"    
 '        True\n'    
 '        >>> # test for redness\n'    
 "        >>> 'red' in tags\n"    
 '        False\n'    
 '        >>> # test for any "subtopic" tag\n'    
 "        >>> 'subtopic' in tags\n"    
 '        True\n'    
 '        >>> # test for subtopic=ontologies\n'    
 '        >>> print(subtopic)\n'    
 '        subtopic=ontologies\n'    
 '        >>> subtopic in tags\n'    
 '        True\n'    
 '        >>> # test for subtopic=libraries\n'    
 "        >>> subtopic2 = Tag('subtopic', 'libraries')\n"    
 '        >>> subtopic2 in tags\n'    
 '        False\n'    
 '\n'    
 '== Ontologies ==\n'    
 '\n'    
 '`Tag`s and `TagSet`s suffice to apply simple annotations to things.\n'    
 'However, an ontology brings meaning to those annotations.\n'    
 '\n'    
 'See the `TagsOntology` class for implementation details,\n'    
 'access methods and more examples.\n'    
 '\n'    
 'Consider a record about a movie, with these tags (a `TagSet`):\n'    
 '\n'    
 '    title="Avengers Assemble"\n'    
 '    series="Avengers (Marvel)"\n'    
 '    cast={"Scarlett Johansson":"Black Widow (Marvel)"}\n'    
 '\n'    
 'where we have the movie title,\n'    
 'a name for the series in which it resides,\n'    
 'and a cast as an association of actors with roles.\n'    
 '\n'    
 'An ontology lets us associate implied types and metadata with these values.\n'    
 '\n'    
 "Here's an example ontology supporting the above `TagSet`:\n"    
 '\n'    
 '    type.cast type=dict key_type=person member_type=character '    
 'description="members of a production"\n'    
 '    type.character description="an identified member of a story"\n'    
 '    type.series type=str\n'    
 '    character.marvel.black_widow type=character names=["Natasha Romanov"]\n'    
 '    person.scarlett_johansson fullname="Scarlett Johansson" bio="Known for '    
 'Black Widow in the Marvel stories."\n'    
 '\n'    
 'The type information for a `cast`\n'    
 'is defined by the ontology entry named `type.cast`,\n'    
 'which tells us that a `cast` `Tag` is a `dict`,\n'    
 'whose keys are of type `person`\n'    
 'and whose values are of type `character`.\n'    
 '(The default type is `str`.)\n'    
 '\n'    
 'To find out the underlying type for a `character`\n'    
 'we look that up in the ontology in turn;\n'    
 'because it does not have a specified `type` `Tag`, it it taken to be a '    
 '`str`.\n'    
 '\n'    
 'Having the types for a `cast`,\n'    
 'it is now possible to look up the metadata for the described cast members.\n'    
 '\n'    
 'The key `"Scarlett Johansson"` is a `person`\n'    
 '(from the type definition of `cast`).\n'    
 'The ontology entry for her is named `person.scarlett_johansson`\n'    
 'which is computed as:\n'    
 '* `person`: the type name\n'    
 '* `scarlett_johansson`: obtained by downcasing `"Scarlett Johansson"`\n'    
 '  and replacing whitespace with an underscore.\n'    
 '  The full conversion process is defined\n'    
 '  by the `TagsOntology.value_to_tag_name` function.\n'    
 '\n'    
 'The key `"Black Widow (Marvel)"` is a `character`\n'    
 '(again, from the type definition of `cast`).\n'    
 'The ontology entry for her is named `character.marvel.black_widow`\n'    
 'which is computed as:\n'    
 '* `character`: the type name\n'    
 '* `marvel.black_widow`: obtained by downcasing `"Black Widow (Marvel)"`,\n'    
 '  replacing whitespace with an underscore,\n'    
 '  and moving a bracketed suffix to the front as an unbracketed prefix.\n'    
 '  The full conversion process is defined\n'    
 '  by the `TagsOntology.value_to_tag_name` function.\n'    
 '\n'    
 '== Format Strings ==\n'    
 '\n'    
 'You can just use `str.format_map` as shown above\n'    
 'for the direct values in a `TagSet`,\n'    
 'since it subclasses `dict`.\n'    
 '\n'    
 'However, `TagSet`s also subclass `cs.lex.FormatableMixin`\n'    
 'and therefore have a richer `format_as` method which has an extended syntax\n'    
 'for the format component.\n'    
 'Command line tools like `fstags` use this for output format specifications.\n'    
 '\n'    
 'An example:\n'    
 '\n'    
 '    >>> # an ontology specifying the type for a colour\n'    
 '    >>> # and some information about the colour "blue"\n'    
 '    >>> ont = TagsOntology(\n'    
 '    ...   {\n'    
 "    ...       'type.colour':\n"    
 '    ...       TagSet(description="a colour, a hue", type="str"),\n'    
 "    ...       'colour.blue':\n"    
 '    ...       TagSet(\n'    
 "    ...           url='https://en.wikipedia.org/wiki/Blue',\n"    
 "    ...           wavelengths='450nm-495nm'\n"    
 '    ...       ),\n'    
 '    ...   }\n'    
 '    ... )\n'    
 '    >>> # tag set with a "blue" tag, using the ontology above\n'    
 "    >>> tags = TagSet(colour='blue', labels=['a', 'b', 'c'], size=9, "    
 '_ontology=ont)\n'    
 "    >>> tags.format_as('The colour is {colour}.')\n"    
 "    'The colour is blue.'\n"    
 '    >>> # format a string about the tags showing some metadata about the '    
 'colour\n'    
 "    >>> tags.format_as('Information about the colour may be found here: "    
 "{colour:metadata.url}')\n"    
 "    'Information about the colour may be found here: "    
 "https://en.wikipedia.org/wiki/Blue'\n"    
 '\n'    
 '## Function `as_unixtime(*a, **kw)`\n'    
 '\n'    
 'Convert a tag value to a UNIX timestamp.\n'    
 '\n'    
 'This accepts `int`, `float` (already a timestamp)\n'    
 'and `date` or `datetime`\n'    
 '(use `datetime.timestamp() for a nonnaive `datetime`,\n'    
 'otherwise `time.mktime(tag_value.time_tuple())`,\n'    
 'which assumes the local time zone).\n'    
 '\n'    
 '## Class `BaseTagSets(cs.resources.MultiOpenMixin, '    
 'cs.context.ContextManagerMixin, collections.abc.MutableMapping, '    
 'collections.abc.Mapping, collections.abc.Collection, collections.abc.Sized, '    
 'collections.abc.Iterable, collections.abc.Container)`\n'    
 '\n'    
 'Base class for collections of `TagSet` instances\n'    
 'such as `cs.fstags.FSTags` and `cs.sqltags.SQLTags`.\n'    
 '\n'    
 'Examples of this include:\n'    
 '* `cs.fstags.FSTags`: a mapping of filesystem paths to their associated '    
 '`TagSet`\n'    
 '* `cs.sqltags.SQLTags`: a mapping of names to `TagSet`s stored in an SQL '    
 'database\n'    
 '\n'    
 'Subclasses must implement:\n'    
 '* `get(name,default=None)`: return the `TagSet` associated\n'    
 '  with `name`, or `default`.\n'    
 '* `__setitem__(name,tagset)`: associate a `TagSet`with the key `name`;\n'    
 '  this is called by the `__missing__` method with a newly created `TagSet`.\n'    
 '* `keys(self)`: return an iterable of names\n'    
 '\n'    
 'Subclasses may reasonably want to override the following:\n'    
 '* `startup_shutdown(self)`: context manager to allocate and release any\n'    
 '  needed resources such as database connections\n'    
 '\n'    
 'Subclasses may implement:\n'    
 '* `__len__(self)`: return the number of names\n'    
 '\n'    
 'The `TagSet` factory used to fetch or create a `TagSet` is\n'    
 'named `TagSetClass`. The default implementation honours two\n'    
 'class attributes:\n'    
 '* `TAGSETCLASS_DEFAULT`: initially `TagSet`\n'    
 '* `TAGSETCLASS_PREFIX_MAPPING`: a mapping of type names to `TagSet` '    
 'subclasses\n'    
 '\n'    
 'The type name of a `TagSet` name is the first dotted component.\n'    
 'For example, `artist.nick_cave` has the type name `artist`.\n'    
 'A subclass of `BaseTagSets` could utiliise an `ArtistTagSet` subclass of '    
 '`TagSet`\n'    
 'and provide:\n'    
 '\n'    
 '    TAGSETCLASS_PREFIX_MAPPING = {\n'    
 "      'artist': ArtistTagSet,\n"    
 '    }\n'    
 '\n'    
 'in its class definition. Accesses to `artist.`* entities would\n'    
 'result in `ArtistTagSet` instances and access to other enitities\n'    
 'would result in ordinary `TagSet` instances.\n'    
 '\n'    
 '*Method `BaseTagSets.__init__(self, *, ontology=None)`*:\n'    
 'Initialise the collection.\n'    
 '\n'    
 '*`BaseTagSets.TAGSETCLASS_DEFAULT`*\n'    
 '\n'    
 '*Method `BaseTagSets.TagSetClass(self, *a, **kw)`*:\n'    
 'Factory to create a new `TagSet` from `name`.\n'    
 '\n'    
 '*Method `BaseTagSets.__contains__(self, name: str)`*:\n'    
 'Test whether `name` is present in the underlying mapping.\n'    
 '\n'    
 '*Method `BaseTagSets.__getitem__(self, name: str)`*:\n'    
 'Obtain the `TagSet` associated with `name`.\n'    
 '\n'    
 'If `name` is not presently mapped,\n'    
 'return `self.__missing__(name)`.\n'    
 '\n'    
 '*Method `BaseTagSets.__iter__(self)`*:\n'    
 'Iteration returns the keys.\n'    
 '\n'    
 '*Method `BaseTagSets.__len__(self)`*:\n'    
 'Return the length of the underlying mapping.\n'    
 '\n'    
 '*Method `BaseTagSets.__missing__(self, *a, **kw)`*:\n'    
 'Like `dict`, the `__missing__` method may autocreate a new `TagSet`.\n'    
 '\n'    
 'This is called from `__getitem__` if `name` is missing\n'    
 'and uses the factory `cls.default_factory`.\n'    
 'If that is `None` raise `KeyError`,\n'    
 'otherwise call `self.default_factory(name,**kw)`.\n'    
 'If that returns `None` raise `KeyError`,\n'    
 'otherwise save the entity under `name` and return the entity.\n'    
 '\n'    
 '*Method `BaseTagSets.__setitem__(self, name, te)`*:\n'    
 'Save `te` in the backend under the key `name`.\n'    
 '\n'    
 '*Method `BaseTagSets.add(self, name: str, **kw)`*:\n'    
 'Return a new `TagSet` associated with `name`,\n'    
 'which should not already be in use.\n'    
 '\n'    
 '*Method `BaseTagSets.default_factory(self, name: str)`*:\n'    
 'Create a new `TagSet` named `name`.\n'    
 '\n'    
 '*Method `BaseTagSets.edit(self, *, select_tagset=None, **kw)`*:\n'    
 'Edit the `TagSet`s.\n'    
 '\n'    
 'Parameters:\n'    
 '* `select_tagset`: optional callable accepting a `TagSet`\n'    
 '  which tests whether it should be included in the `TagSet`s\n'    
 '  to be edited\n'    
 'Other keyword arguments are passed to `Tag.edit_tagsets`.\n'    
 '\n'    
 '*Method `BaseTagSets.get(self, name: str, default=None)`*:\n'    
 'Return the `TagSet` associated with `name`,\n'    
 'or `default` if there is no such entity.\n'    
 '\n'    
 '*Method `BaseTagSets.items(self, *, prefix=None)`*:\n'    
 'Generator yielding `(key,value)` pairs,\n'    
 "optionally constrained to keys starting with `prefix+'.'`.\n"    
 '\n'    
 '*Method `BaseTagSets.keys(self, *, prefix=None)`*:\n'    
 "Return the keys starting with `prefix+'.'`\n"    
 'or all keys if `prefix` is `None`.\n'    
 '\n'    
 '*Method `BaseTagSets.subdomain(self, subname: str)`*:\n'    
 'Return a proxy for this `BaseTagSets` for the `name`s\n'    
 "starting with `subname+'.'`.\n"    
 '\n'    
 '*Method `BaseTagSets.values(self, *, prefix=None)`*:\n'    
 'Generator yielding the mapping values (`TagSet`s),\n'    
 "optionally constrained to keys starting with `prefix+'.'`.\n"    
 '\n'    
 '## Class `MappingTagSets(BaseTagSets, cs.resources.MultiOpenMixin, '    
 'cs.context.ContextManagerMixin, collections.abc.MutableMapping, '    
 'collections.abc.Mapping, collections.abc.Collection, collections.abc.Sized, '    
 'collections.abc.Iterable, collections.abc.Container)`\n'    
 '\n'    
 'A `BaseTagSets` subclass using an arbitrary mapping.\n'    
 '\n'    
 'If no mapping is supplied, a `dict` is created for the purpose.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '    >>> tagsets = MappingTagSets()\n'    
 '    >>> list(tagsets.keys())\n'    
 '    []\n'    
 "    >>> tagsets.get('foo')\n"    
 "    >>> tagsets['foo'] = TagSet(bah=1, zot=2)\n"    
 '    >>> list(tagsets.keys())\n'    
 "    ['foo']\n"    
 "    >>> tagsets.get('foo')\n"    
 "    TagSet:{'bah': 1, 'zot': 2}\n"    
 "    >>> list(tagsets.keys(prefix='foo'))\n"    
 "    ['foo']\n"    
 "    >>> list(tagsets.keys(prefix='bah'))\n"    
 '    []\n'    
 '\n'    
 '*Method `MappingTagSets.__delitem__(self, name)`*:\n'    
 'Delete the `TagSet` named `name`.\n'    
 '\n'    
 '*Method `MappingTagSets.__setitem__(self, name, te)`*:\n'    
 'Save `te` in the backend under the key `name`.\n'    
 '\n'    
 '*Method `MappingTagSets.keys(self, *, prefix: Optional[str] = None)`*:\n'    
 'Return an iterable of the keys commencing with `prefix`\n'    
 'or all keys if `prefix` is `None`.\n'    
 '\n'    
 '## Class `RegexpTagRule`\n'    
 '\n'    
 'A regular expression based `Tag` rule.\n'    
 '\n'    
 'This applies a regular expression to a string\n'    
 'and returns inferred `Tag`s.\n'    
 '\n'    
 '*Method `RegexpTagRule.infer_tags(self, *a, **kw)`*:\n'    
 'Apply the rule to the string `s`, return a list of `Tag`s.\n'    
 '\n'    
 '## Function `selftest(argv)`\n'    
 '\n'    
 'Run some ad hoc self tests.\n'    
 '\n'    
 '## Class `Tag(Tag, builtins.tuple, cs.lex.FormatableMixin, '    
 'cs.lex.FormatableFormatter, string.Formatter)`\n'    
 '\n'    
 'A `Tag` has a `.name` (`str`) and a `.value`\n'    
 'and an optional `.ontology`.\n'    
 '\n'    
 'The `name` must be a dotted identifier.\n'    
 '\n'    
 'Terminology:\n'    
 '* A "bare" `Tag` has a `value` of `None`.\n'    
 '* A "naive" `Tag` has an `ontology` of `None`.\n'    
 '\n'    
 'The constructor for a `Tag` is unusual:\n'    
 '* both the `value` and `ontology` are optional,\n'    
 '  defaulting to `None`\n'    
 '* if `name` is a `str` then we always construct a new `Tag`\n'    
 '  with the suppplied values\n'    
 '* if `name` is not a `str`\n'    
 '  it should be a `Tag`like object to promote;\n'    
 '  it is an error if the `value` parameter is not `None`\n'    
 '  in this case\n'    
 '* an optional `prefix` may be supplied\n'    
 "  which is prepended to `name` with a dot (`'.'`) if not empty\n"    
 '\n'    
 'The promotion process is as follows:\n'    
 '* if `name` is a `Tag` subinstance\n'    
 '  then if the supplied `ontology` is not `None`\n'    
 '  and is not the ontology associated with `name`\n'    
 '  then a new `Tag` is made,\n'    
 '  otherwise the original `Tag` is returned unchanged\n'    
 '* otherwise a new `Tag` is made from `name`\n'    
 '  using its `.value`\n'    
 '  and overriding its `.ontology`\n'    
 '  if the `ontology` parameter is not `None`\n'    
 '\n'    
 'Examples:\n'    
 '\n'    
 "    >>> ont = TagsOntology({'colour.blue': "    
 "TagSet(wavelengths='450nm-495nm')})\n"    
 "    >>> tag0 = Tag('colour', 'blue')\n"    
 '    >>> tag0\n'    
 "    Tag(name='colour',value='blue')\n"    
 '    >>> tag = Tag(tag0)\n'    
 '    >>> tag\n'    
 "    Tag(name='colour',value='blue')\n"    
 '    >>> tag = Tag(tag0, ontology=ont)\n'    
 '    >>> tag # doctest: +ELLIPSIS\n'    
 "    Tag(name='colour',value='blue',ontology=...)\n"    
 "    >>> tag = Tag(tag0, prefix='surface')\n"    
 '    >>> tag\n'    
 "    Tag(name='surface.colour',value='blue')\n"    
 '\n'    
 '*Method `Tag.__init__(self, *a, **kw)`*:\n'    
 'Dummy `__init__` to avoid `FormatableMixin.__init__`\n'    
 'because we subclass `namedtuple` which has no `__init__`.\n'    
 '\n'    
 '*`Tag.__hash__`*\n'    
 '\n'    
 '*Method `Tag.__str__(self)`*:\n'    
 'Encode `name` and `value`.\n'    
 '\n'    
 '*Method `Tag.alt_values(self, value_tag_name=None)`*:\n'    
 'Return a list of alternative values for this `Tag`\n'    
 'on the premise that each has a metadata entry.\n'    
 '\n'    
 '*Property `Tag.basetype`*:\n'    
 'The base type name for this tag.\n'    
 'Returns `None` if there is no ontology.\n'    
 '\n'    
 'This calls `self.onotology.basetype(self.name)`.\n'    
 'The basetype is the endpoint of a cascade down the defined types.\n'    
 '\n'    
 'For example, this might tell us that a `Tag` `role="Fred"`\n'    
 'has a basetype `"str"`\n'    
 'by cascading through a hypothetical chain `role`->`character`->`str`:\n'    
 '\n'    
 '    type.role type=character\n'    
 '    type.character type=str\n'    
 '\n'    
 '*Method `Tag.from_arg(arg, offset=0, ontology=None)`*:\n'    
 'Parse a `Tag` from the string `arg` at `offset` (default `0`).\n'    
 'where `arg` is known to be entirely composed of the value,\n'    
 'such as a command line argument.\n'    
 '\n'    
 'This calls the `from_str` method with `fallback_parse` set\n'    
 'to gather then entire tail of the supplied string `arg`.\n'    
 '\n'    
 '*Method `Tag.from_str(s, offset=0, ontology=None, fallback_parse=None)`*:\n'    
 'Parse a `Tag` definition from `s` at `offset` (default `0`).\n'    
 '\n'    
 '*Method `Tag.from_str2(s, offset=0, *, ontology, extra_types=None, '    
 'fallback_parse=None)`*:\n'    
 'Parse tag_name[=value], return `(Tag,offset)`.\n'    
 '\n'    
 '*Method `Tag.is_valid_name(name)`*:\n'    
 'Test whether a tag name is valid: a dotted identifier.\n'    
 '\n'    
 '*Method `Tag.key_metadata(self, *a, **kw)`*:\n'    
 'Return the metadata definition for `key`.\n'    
 '\n'    
 'The metadata `TagSet` is obtained from the ontology entry\n'    
 '*type*`.`*key_tag_name*\n'    
 "where *type* is the `Tag`'s `key_type`\n"    
 'and *key_tag_name* is the key converted\n'    
 'into a dotted identifier by `TagsOntology.value_to_tag_name`.\n'    
 '\n'    
 '*Property `Tag.key_type`*:\n'    
 'The type name for members of this tag.\n'    
 '\n'    
 'This is required if `.value` is a mapping.\n'    
 '\n'    
 '*Property `Tag.key_typedef`*:\n'    
 "The typedata definition for this `Tag`'s keys.\n"    
 '\n'    
 'This is for `Tag`s which store mappings,\n'    
 'for example a movie cast, mapping actors to roles.\n'    
 '\n'    
 'The name of the member type comes from\n'    
 'the `key_type` entry from `self.typedata`.\n'    
 "That name is then looked up in the ontology's types.\n"    
 '\n'    
 '*Method `Tag.matches(self, name, value=None, *a, **kw)`*:\n'    
 'Test whether this `Tag` matches `(tag_name,value)`.\n'    
 '\n'    
 '*Method `Tag.member_metadata(self, *a, **kw)`*:\n'    
 'Return the metadata definition for self[member_key].\n'    
 '\n'    
 'The metadata `TagSet` is obtained from the ontology entry\n'    
 '*type*`.`*member_tag_name*\n'    
 "where *type* is the `Tag`'s `member_type`\n"    
 'and *member_tag_name* is the member value converted\n'    
 'into a dotted identifier by `TagsOntology.value_to_tag_name`.\n'    
 '\n'    
 '*Property `Tag.member_type`*:\n'    
 'The type name for members of this tag.\n'    
 '\n'    
 'This is required if `.value` is a sequence or mapping.\n'    
 '\n'    
 '*Property `Tag.member_typedef`*:\n'    
 "The typedata definition for this `Tag`'s members.\n"    
 '\n'    
 'This is for `Tag`s which store mappings or sequences,\n'    
 'for example a movie cast, mapping actors to roles,\n'    
 'or a list of scenes.\n'    
 '\n'    
 'The name of the member type comes from\n'    
 'the `member_type` entry from `self.typedata`.\n'    
 "That name is then looked up in the ontology's types.\n"    
 '\n'    
 '*Property `Tag.meta`*:\n'    
 'Shortcut property for the metadata `TagSet`.\n'    
 '\n'    
 '*Method `Tag.metadata(self, *, ontology=None, convert=None)`*:\n'    
 'Fetch the metadata information about this specific tag value,\n'    
 'derived through the `ontology` from the tag name and value.\n'    
 'The default `ontology` is `self.ontology`.\n'    
 '\n'    
 'For a scalar type (`int`, `float`, `str`) this is the ontology `TagSet`\n'    
 'for `self.value`.\n'    
 '\n'    
 'For a sequence (`list`) this is a list of the metadata\n'    
 'for each member.\n'    
 '\n'    
 'For a mapping (`dict`) this is mapping of `key->metadata`.\n'    
 '\n'    
 '*Method `Tag.parse_name(s, offset=0)`*:\n'    
 'Parse a tag name from `s` at `offset`: a dotted identifier.\n'    
 '\n'    
 '*Method `Tag.parse_value(s, offset=0, extra_types=None, '    
 'fallback_parse=None)`*:\n'    
 'Parse a value from `s` at `offset` (default `0`).\n'    
 'Return the value, or `None` on no data.\n'    
 '\n'    
 'The optional `extra_types` parameter may be an iterable of\n'    
 '`(type,from_str,to_str)` tuples where `from_str` is a\n'    
 'function which takes a string and returns a Python object\n'    
 '(expected to be an instance of `type`).\n'    
 'The default comes from `cls.EXTRA_TYPES`.\n'    
 'This supports storage of nonJSONable values in text form.\n'    
 '\n'    
 'The optional `fallback_parse` parameter\n'    
 'specifies a parse function accepting `(s,offset)`\n'    
 'and returning `(parsed,new_offset)`\n'    
 'where `parsed` is text from `s[offset:]`\n'    
 'and `new_offset` is where the parse stopped.\n'    
 'The default is `cs.lex.get_nonwhite`\n'    
 'to gather nonwhitespace characters,\n'    
 'intended support *tag_name*`=`*bare_word*\n'    
 'in human edited tag files.\n'    
 '\n'    
 'The core syntax for values is JSON;\n'    
 'value text commencing with any of `\'"\'`, `\'[\'` or `\'{\'`\n'    
 'is treated as JSON and decoded directly,\n'    
 'leaving the offset at the end of the JSON parse.\n'    
 '\n'    
 'Otherwise all the nonwhitespace at this point is collected\n'    
 'as the value text,\n'    
 'leaving the offset at the next whitespace character\n'    
 'or the end of the string.\n'    
 'The text so collected is then tried against the `from_str`\n'    
 'function of each `extra_types`;\n'    
 'the first successful parse is accepted as the value.\n'    
 'If no extra type match,\n'    
 'the text is tried against `int()` and `float()`;\n'    
 'if one of these parses the text and `str()` of the result round trips\n'    
 'to the original text\n'    
 'then that value is used.\n'    
 'Otherwise the text itself is kept as the value.\n'    
 '\n'    
 '*Method `Tag.transcribe_value(value, extra_types=None, '    
 'json_options=None)`*:\n'    
 'Transcribe `value` for use in `Tag` transcription.\n'    
 '\n'    
 'The optional `extra_types` parameter may be an iterable of\n'    
 '`(type,from_str,to_str)` tuples where `to_str` is a\n'    
 'function which takes a string and returns a Python object\n'    
 '(expected to be an instance of `type`).\n'    
 'The default comes from `cls.EXTRA_TYPES`.\n'    
 '\n'    
 'If `value` is an instance of `type`\n'    
 'then the `to_str` function is used to transcribe the value\n'    
 'as a `str`, which should not include any whitespace\n'    
 '(because of the implementation of `parse_value`).\n'    
 'If there is no matching `to_str` function,\n'    
 '`cls.JSON_ENCODER.encode` is used to transcribe `value`.\n'    
 '\n'    
 'This supports storage of nonJSONable values in text form.\n'    
 '\n'    
 '*Property `Tag.typedef`*:\n'    
 "The defining `TagSet` for this tag's name.\n"    
 '\n'    
 'This is how its type is defined,\n'    
 'and is obtained from:\n'    
 "`self.ontology['type.'+self.name]`\n"    
 '\n'    
 'Basic `Tag`s often do not need a type definition;\n'    
 'these are only needed for structured tag values\n'    
 '(example: a mapping of cast members)\n'    
 'or when a `Tag` name is an alias for another type\n'    
 '(example: a cast member name might be an `actor`\n'    
 'which in turn might be a `person`).\n'    
 '\n'    
 'For example, a `Tag` `colour=blue`\n'    
 'gets its type information from the `type.colour` entry in an ontology;\n'    
 'that entry is just a `TagSet` with relevant information.\n'    
 '\n'    
 '## Function `tag_or_tag_value(*da, **dkw)`\n'    
 '\n'    
 'A decorator for functions or methods which may be called as:\n'    
 '\n'    
 '    func(name, [value])\n'    
 '\n'    
 'or as:\n'    
 '\n'    
 '    func(Tag, [None])\n'    
 '\n'    
 'The optional decorator argument `no_self` (default `False`)\n'    
 'should be supplied for plain functions\n'    
 'as they have no leading `self` parameter to accomodate.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '    @tag_or_tag_value\n'    
 '    def add(self, tag_name, value, *, verbose=None):\n'    
 '\n'    
 'This defines a `.add()` method\n'    
 'which can be called with `name` and `value`\n'    
 'or with single `Tag`like object\n'    
 '(something with `.name` and `.value` attributes),\n'    
 'for example:\n'    
 '\n'    
 '    tags = TagSet()\n'    
 '    ....\n'    
 "    tags.add('colour', 'blue')\n"    
 '    ....\n'    
 "    tag = Tag('size', 9)\n"    
 '    tags.add(tag)\n'    
 '\n'    
 '## Class `TagBasedTest(TagBasedTest, builtins.tuple, TagSetCriterion)`\n'    
 '\n'    
 'A test based on a `Tag`.\n'    
 '\n'    
 'Attributes:\n'    
 '* `spec`: the source text from which this choice was parsed,\n'    
 '  possibly `None`\n'    
 '* `choice`: the apply/reject flag\n'    
 '* `tag`: the `Tag` representing the criterion\n'    
 '* `comparison`: an indication of the test comparison\n'    
 '\n'    
 'The following comparison values are recognised:\n'    
 '* `None`: test for the presence of the `Tag`\n'    
 "* `'='`: test that the tag value equals `tag.value`\n"    
 "* `'<'`: test that the tag value is less than `tag.value`\n"    
 "* `'<='`: test that the tag value is less than or equal to `tag.value`\n"    
 "* `'>'`: test that the tag value is greater than `tag.value`\n"    
 "* `'>='`: test that the tag value is greater than or equal to `tag.value`\n"    
 "* `'~/'`: test if the tag value as a regexp is present in `tag.value`\n"    
 "* '~': test if a matching tag value is present in `tag.value`\n"    
 '\n'    
 '*Method `TagBasedTest.by_tag_value(name, value=None, *a, **kw)`*:\n'    
 'Return a `TagBasedTest` based on a `Tag` or `tag_name,tag_value`.\n'    
 '\n'    
 "*Method `TagBasedTest.match_tagged_entity(self, te: 'TagSet') -> bool`*:\n"    
 'Test against the `Tag`s in `tags`.\n'    
 '\n'    
 '*Note*: comparisons when `self.tag.name` is not in `tags`\n'    
 'always return `False` (possibly inverted by `self.choice`).\n'    
 '\n'    
 '*Method `TagBasedTest.parse(s, offset=0, delim=None)`*:\n'    
 "Parse *tag_name*[{`<`|`<=`|'='|'>='|`>`|'~'}*value*]\n"    
 'and return `(dict,offset)`\n'    
 'where the `dict` contains the following keys and values:\n'    
 '* `tag`: a `Tag` embodying the tag name and value\n'    
 '* `comparison`: an indication of the test comparison\n'    
 '\n'    
 '## Class `TagFile(cs.obj.SingletonMixin, BaseTagSets, '    
 'cs.resources.MultiOpenMixin, cs.context.ContextManagerMixin, '    
 'collections.abc.MutableMapping, collections.abc.Mapping, '    
 'collections.abc.Collection, collections.abc.Sized, collections.abc.Iterable, '    
 'collections.abc.Container)`\n'    
 '\n'    
 'A reference to a specific file containing tags.\n'    
 '\n'    
 'This manages a mapping of `name` => `TagSet`,\n'    
 'itself a mapping of tag name => tag value.\n'    
 '\n'    
 '*Method `TagFile.__setitem__(self, name, te)`*:\n'    
 'Set item `name` to `te`.\n'    
 '\n'    
 '*Method `TagFile.get(self, name, default=None)`*:\n'    
 'Get from the tagsets.\n'    
 '\n'    
 '*Method `TagFile.is_modified(self)`*:\n'    
 'Test whether this `TagSet` has been modified.\n'    
 '\n'    
 '*Method `TagFile.keys(self, *, prefix=None)`*:\n'    
 '`tagsets.keys`\n'    
 '\n'    
 'If the options `prefix` is supplied,\n'    
 'yield only those keys starting with `prefix`.\n'    
 '\n'    
 '*Method `TagFile.load_tagsets(filepath, ontology, extra_types=None)`*:\n'    
 'Load `filepath` and return `(tagsets,unparsed)`.\n'    
 '\n'    
 'The returned `tagsets` are a mapping of `name`=>`tag_name`=>`value`.\n'    
 'The returned `unparsed` is a list of `(lineno,line)`\n'    
 'for lines which failed the parse (excluding the trailing newline).\n'    
 '\n'    
 '*Property `TagFile.names`*:\n'    
 'The names from this `FSTagsTagFile` as a list.\n'    
 '\n'    
 '*Method `TagFile.parse_tags_line(*a, **kw)`*:\n'    
 'Parse a "name tags..." line as from a `.fstags` file,\n'    
 'return `(name,TagSet)`.\n'    
 '\n'    
 '*Method `TagFile.save(self, extra_types=None)`*:\n'    
 'Save the tag map to the tag file if modified.\n'    
 '\n'    
 '*Method `TagFile.save_tagsets(*a, **kw)`*:\n'    
 'Save `tagsets` and `unparsed` to `filepath`.\n'    
 '\n'    
 'This method will create the required intermediate directories\n'    
 'if missing.\n'    
 '\n'    
 'This method *does not* clear the `.modified` attribute of the `TagSet`s\n'    
 "because it does not know it is saving to the `Tagset`'s primary location.\n"    
 '\n'    
 '*Method `TagFile.shutdown(self)`*:\n'    
 'Save the tagsets if modified.\n'    
 '\n'    
 '*Method `TagFile.startup(self)`*:\n'    
 'No special startup.\n'    
 '\n'    
 '*Method `TagFile.tags_line(name, tags, extra_types=None)`*:\n'    
 'Transcribe a `name` and its `tags` for use as a `.fstags` file line.\n'    
 '\n'    
 '*Property `TagFile.tagsets`*:\n'    
 'The tag map from the tag file,\n'    
 'a mapping of name=>`TagSet`.\n'    
 '\n'    
 'This is loaded on demand.\n'    
 '\n'    
 '*Method `TagFile.update(self, name, tags, *, prefix=None, verbose=None)`*:\n'    
 'Update the tags for `name` from the supplied `tags`\n'    
 'as for `Tagset.update`.\n'    
 '\n'    
 '## Class `TagsCommandMixin`\n'    
 '\n'    
 'Utility methods for `cs.cmdutils.BaseCommand` classes working with tags.\n'    
 '\n'    
 'Optional subclass attributes:\n'    
 '* `TAGSET_CRITERION_CLASS`: a `TagSetCriterion` duck class,\n'    
 '  default `TagSetCriterion`.\n'    
 '  For example, `cs.sqltags` has a subclass\n'    
 '  with an `.extend_query` method for computing an SQL JOIN\n'    
 '  used in searching for tagged entities.\n'    
 '\n'    
 '*`TagsCommandMixin.TagAddRemove`*\n'    
 '\n'    
 '*Method `TagsCommandMixin.parse_tag_addremove(arg, offset=0)`*:\n'    
 'Parse `arg` as an add/remove tag specification\n'    
 'of the form [`-`]*tag_name*[`=`*value*].\n'    
 'Return `(remove,Tag)`.\n'    
 '\n'    
 'Examples:\n'    
 '\n'    
 "    >>> TagsCommandMixin.parse_tag_addremove('a')\n"    
 "    TagAddRemove(remove=False, tag=Tag(name='a',value=None))\n"    
 "    >>> TagsCommandMixin.parse_tag_addremove('-a')\n"    
 "    TagAddRemove(remove=True, tag=Tag(name='a',value=None))\n"    
 "    >>> TagsCommandMixin.parse_tag_addremove('a=1')\n"    
 "    TagAddRemove(remove=False, tag=Tag(name='a',value=1))\n"    
 "    >>> TagsCommandMixin.parse_tag_addremove('-a=1')\n"    
 "    TagAddRemove(remove=True, tag=Tag(name='a',value=1))\n"    
 '    >>> TagsCommandMixin.parse_tag_addremove(\'-a="foo bah"\')\n'    
 "    TagAddRemove(remove=True, tag=Tag(name='a',value='foo bah'))\n"    
 "    >>> TagsCommandMixin.parse_tag_addremove('-a=foo bah')\n"    
 "    TagAddRemove(remove=True, tag=Tag(name='a',value='foo bah'))\n"    
 '\n'    
 '*Method `TagsCommandMixin.parse_tag_choices(argv)`*:\n'    
 'Parse `argv` as an iterable of [`!`]*tag_name*[`=`*tag_value`] `Tag`\n'    
 'additions/deletions.\n'    
 '\n'    
 '*Method `TagsCommandMixin.parse_tagset_criteria(argv, '    
 'tag_based_test_class=None)`*:\n'    
 'Parse tag specifications from `argv` until an unparseable item is found.\n'    
 'Return `(criteria,argv)`\n'    
 'where `criteria` is a list of the parsed criteria\n'    
 'and `argv` is the remaining unparsed items.\n'    
 '\n'    
 'Each item is parsed via\n'    
 '`cls.parse_tagset_criterion(item,tag_based_test_class)`.\n'    
 '\n'    
 '*Method `TagsCommandMixin.parse_tagset_criterion(arg, '    
 'tag_based_test_class=None)`*:\n'    
 'Parse `arg` as a tag specification\n'    
 'and return a `tag_based_test_class` instance\n'    
 'via its `.from_str` factory method.\n'    
 'Raises `ValueError` in a misparse.\n'    
 'The default `tag_based_test_class`\n'    
 'comes from `cls.TAGSET_CRITERION_CLASS`,\n'    
 'which itself defaults to class `TagSetCriterion`.\n'    
 '\n'    
 'The default `TagSetCriterion.from_str` recognises:\n'    
 '* `-`*tag_name*: a negative requirement for *tag_name*\n'    
 '* *tag_name*[`=`*value*]: a positive requirement for a *tag_name*\n'    
 '  with optional *value*.\n'    
 '\n'    
 '## Class `TagSet(builtins.dict, cs.dateutils.UNIXTimeMixin, '    
 'cs.lex.FormatableMixin, cs.lex.FormatableFormatter, string.Formatter, '    
 'cs.mappings.AttrableMappingMixin)`\n'    
 '\n'    
 'A setlike class associating a set of tag names with values.\n'    
 '\n'    
 'This actually subclasses `dict`, so a `TagSet` is a direct\n'    
 'mapping of tag names to values.\n'    
 'It accepts attribute access to simple tag values when they\n'    
 'do not conflict with the class methods;\n'    
 'the reliable method is normal item access.\n'    
 '\n'    
 '*NOTE*: iteration yields `Tag`s, not dict keys.\n'    
 '\n'    
 'Also note that all the `Tags` from `TagSet`\n'    
 'share its ontology.\n'    
 '\n'    
 'Subclasses should override the `set` and `discard` methods;\n'    
 'the `dict` and mapping methods\n'    
 'are defined in terms of these two basic operations.\n'    
 '\n'    
 '`TagSet`s have a few special properties:\n'    
 '* `id`: a domain specific identifier;\n'    
 '  this may reasonably be `None` for entities\n'    
 '  not associated with database rows;\n'    
 '  the `cs.sqltags.SQLTags` class associates this\n'    
 '  with the database row id.\n'    
 "* `name`: the entity's name;\n"    
 "  a read only alias for the `'name'` `Tag`.\n"    
 '  The `cs.sqltags.SQLTags` class defines "log entries"\n'    
 '  as `TagSet`s with no `name`.\n'    
 '* `unixtime`: a UNIX timestamp,\n'    
 '  a `float` holding seconds since the UNIX epoch\n'    
 '  (midnight, 1 January 1970 UTC).\n'    
 '  This is typically the row creation time\n'    
 '  for entities associated with database rows.\n'    
 '\n'    
 'Because ` TagSet` subclasses `cs.mappings.AttrableMappingMixin`\n'    
 'you can also access tag values as attributes\n'    
 'provided that they do not conflict with instance attributes\n'    
 'or class methods or properties.\n'    
 'The `TagSet` class defines the class attribute `ATTRABLE_MAPPING_DEFAULT`\n'    
 'as `None` which causes attribute access to return `None`\n'    
 'for missing tag names.\n'    
 'This supports code like:\n'    
 '\n'    
 '    if tags.title:\n'    
 '        # use the title in something\n'    
 '    else:\n'    
 '        # handle a missing title tag\n'    
 '\n'    
 '*Method `TagSet.__init__(self, *a, **kw)`*:\n'    
 'Initialise the `TagSet`.\n'    
 '\n'    
 'Parameters:\n'    
 '* positional parameters initialise the `dict`\n'    
 '  and are passed to `dict.__init__`\n'    
 '* `_id`: optional identity value for databaselike implementations\n'    
 '* `_ontology`: optional `TagsOntology to use for this `TagSet`\n'    
 '* other alphabetic keyword parameters are also used to initialise the\n'    
 '  `dict` and are passed to `dict.__init__`\n'    
 '\n'    
 '*Method `TagSet.__contains__(self, tag)`*:\n'    
 'Test for a tag being in this `TagSet`.\n'    
 '\n'    
 'If the supplied `tag` is a `str` then this test\n'    
 'is for the presence of `tag` in the keys.\n'    
 '\n'    
 'Otherwise,\n'    
 'for each tag `T` in the tagset\n'    
 'test `T.matches(tag)` and return `True` on success.\n'    
 'The default `Tag.matches` method compares the tag name\n'    
 'and if the same,\n'    
 'returns true if `tag.value` is `None` (basic "is the tag present" test)\n'    
 'and otherwise true if `tag.value==T.value` (basic "tag value equality" '    
 'test).\n'    
 '\n'    
 'Otherwise return `False`.\n'    
 '\n'    
 '*Method `TagSet.__getattr__(self, attr)`*:\n'    
 'Support access to dotted name attributes.\n'    
 '\n'    
 'The following attribute access are supported:\n'    
 '\n'    
 'If `attr` is a key, return `self[attr]`.\n'    
 '\n'    
 'If `self.auto_infer(attr)` does not raise `ValueError`,\n'    
 'return that value.\n'    
 '\n'    
 'If this `TagSet` has an ontology\n'    
 'and `attr looks like *typename*`_`*fieldname*\n'    
 'and *typename* is a key,\n'    
 'look up the metadata for the `Tag` value\n'    
 "and return the metadata's *fieldname* key.\n"    
 'This also works for plural values.\n'    
 '\n'    
 'For example if a `TagSet` has the tag `artists=["fred","joe"]`\n'    
 'and `attr` is `artist_names`\n'    
 'then the metadata entries for `"fred"` and `"joe"` looked up\n'    
 'and their `artist_name` tags are returned,\n'    
 'perhaps resulting in the list\n'    
 '`["Fred Thing","Joe Thang"]`.\n'    
 '\n'    
 "If there are keys commencing with `attr+'.'`\n"    
 'then this returns a view of those keys\n'    
 'so that a subsequent attribute access can access one of those keys.\n'    
 '\n'    
 'Otherwise, a superclass attribute access is performed.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '    >>> tags=TagSet(a=1,b=2)\n'    
 '    >>> tags.a\n'    
 '    1\n'    
 '    >>> tags.c\n'    
 "    >>> tags['c.z']=9\n"    
 "    >>> tags['c.x']=8\n"    
 '    >>> tags\n'    
 "    TagSet:{'a': 1, 'b': 2, 'c.z': 9, 'c.x': 8}\n"    
 '    >>> tags.c\n'    
 "    TagSetPrefixView:c.{'z': 9, 'x': 8}\n"    
 '    >>> tags.c.z\n'    
 '    9\n'    
 '\n'    
 "However, this is not supported when there is a tag named `'c'`\n"    
 "because `tags.c` has to return the `'c'` tag value:\n"    
 '\n'    
 '    >>> tags=TagSet(a=1,b=2,c=3)\n'    
 '    >>> tags.a\n'    
 '    1\n'    
 '    >>> tags.c\n'    
 '    3\n'    
 "    >>> tags['c.z']=9\n"    
 '    >>> tags.c.z\n'    
 '    Traceback (most recent call last):\n'    
 '      File "<stdin>", line 1, in <module>\n'    
 "    AttributeError: 'int' object has no attribute 'z'\n"    
 '\n'    
 '*Method `TagSet.__iter__(self, prefix=None, ontology=None)`*:\n'    
 'Yield the tag data as `Tag`s.\n'    
 '\n'    
 '*Method `TagSet.__setattr__(self, attr, value)`*:\n'    
 'Attribute based `Tag` access.\n'    
 '\n'    
 'If `attr` is private or is in `self.__dict__` then that is updated,\n'    
 'supporting "normal" attributes set on the instance.\n'    
 'Otherwise the `Tag` named `attr` is set to `value`.\n'    
 '\n'    
 'The `__init__` methods of subclasses should do something like this\n'    
 '(from `TagSet.__init__`)\n'    
 'to set up the ordinary instance attributes\n'    
 'which are not to be treated as `Tag`s:\n'    
 '\n'    
 '    self.__dict__.update(id=_id, ontology=_ontology, modified=False)\n'    
 '\n'    
 '*Method `TagSet.__str__(self)`*:\n'    
 'The `TagSet` suitable for writing to a tag file.\n'    
 '\n'    
 '*Method `TagSet.add(self, name, value=None, *a, **kw)`*:\n'    
 'Adding a `Tag` calls the class `set()` method.\n'    
 '\n'    
 '*Method `TagSet.as_dict(self)`*:\n'    
 'Return a `dict` mapping tag name to value.\n'    
 '\n'    
 '*Method `TagSet.as_tags(self, prefix=None, ontology=None)`*:\n'    
 'Yield the tag data as `Tag`s.\n'    
 '\n'    
 '*Method `TagSet.auto_infer(self, *a, **kw)`*:\n'    
 'The default inference implementation.\n'    
 '\n'    
 'This should return a value if `attr` is inferrable\n'    
 'and raise `ValueError` if not.\n'    
 '\n'    
 'The default implementation returns the direct tag value for `attr`\n'    
 'if present.\n'    
 '\n'    
 '*Property `TagSet.csvrow`*:\n'    
 'This `TagSet` as a list useful to a `csv.writer`.\n'    
 'The inverse of `from_csvrow`.\n'    
 '\n'    
 '*Method `TagSet.discard(self, name, value=None, *a, **kw)`*:\n'    
 'Discard the tag matching `(tag_name,value)`.\n'    
 'Return a `Tag` with the old value,\n'    
 'or `None` if there was no matching tag.\n'    
 '\n'    
 'Note that if the tag value is `None`\n'    
 'then the tag is unconditionally discarded.\n'    
 'Otherwise the tag is only discarded\n'    
 'if its value matches.\n'    
 '\n'    
 '*Method `TagSet.edit(self, editor=None, verbose=None)`*:\n'    
 'Edit this `TagSet`.\n'    
 '\n'    
 '*Method `TagSet.edit_tagsets(*a, **kw)`*:\n'    
 'Edit a collection of `TagSet`s.\n'    
 'Return a list of `(old_name,new_name,TagSet)` for those which were '    
 'modified.\n'    
 '\n'    
 'This function supports modifying both `name` and `Tag`s.\n'    
 'The `Tag`s are updated directly.\n'    
 'The changed names are returning in the `old_name,new_name` above.\n'    
 '\n'    
 'The collection `tes` may be either a mapping of name/key\n'    
 'to `TagSet` or an iterable of `TagSets`. If the latter, a\n'    
 'mapping is made based on `te.name or te.id` for each item\n'    
 '`te` in the iterable.\n'    
 '\n'    
 '*Method `TagSet.from_csvrow(csvrow)`*:\n'    
 'Construct a `TagSet` from a CSV row like that from\n'    
 '`TagSet.csvrow`, being `unixtime,id,name,tags...`.\n'    
 '\n'    
 '*Method `TagSet.from_line(line, offset=0, *, ontology=None, '    
 'extra_types=None, verbose=None)`*:\n'    
 'Create a new `TagSet` from a line of text.\n'    
 '\n'    
 '*Method `TagSet.get_arg_name(self, field_name)`*:\n'    
 'Override for `FormattableMixin.get_arg_name`:\n'    
 'return the leading dotted identifier,\n'    
 'which represents a tag or tag prefix.\n'    
 '\n'    
 '*Method `TagSet.get_value(self, arg_name, a, kw)`*:\n'    
 'Override for `FormattableMixin.get_value`:\n'    
 'look up `arg_name` in `kw`, return a value.\n'    
 '\n'    
 'The value is obtained as follows:\n'    
 '* `kw[arg_name]`: the `Tag` named `arg_name` if present\n'    
 '* `kw.get_format_attribute(arg_name)`:\n'    
 '  a formattable attribute named `arg_name`\n'    
 'otherwise raise `KeyError` if `self.format_mode.strict`\n'    
 "otherwise return the placeholder string `'{'+arg_name+'}'`.\n"    
 '\n'    
 '*Property `TagSet.name`*:\n'    
 "Read only `name` property, `None` if there is no `'name'` tag.\n"    
 '\n'    
 '*Method `TagSet.set(self, name, value=None, *a, **kw)`*:\n'    
 'Set `self[tag_name]=value`.\n'    
 'If `verbose`, emit an info message if this changes the previous value.\n'    
 '\n'    
 '*Method `TagSet.set_from(self, other, verbose=None)`*:\n'    
 'Completely replace the values in `self`\n'    
 'with the values from `other`,\n'    
 'a `TagSet` or any other `name`=>`value` dict.\n'    
 '\n'    
 'This has the feature of logging changes\n'    
 'by calling `.set` and `.discard` to effect the changes.\n'    
 '\n'    
 '*Method `TagSet.subtags(self, prefix, as_tagset=False)`*:\n'    
 "Return `TagSetPrefixView` of the tags commencing with `prefix+'.'`\n"    
 'with the key prefixes stripped off.\n'    
 '\n'    
 'If `as_tagset` is true (default `False`)\n'    
 'return a new standalone `TagSet` containing the prefixed keys.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 "    >>> tags = TagSet({'a.b':1, 'a.d':2, 'c.e':3})\n"    
 "    >>> tags.subtags('a')\n"    
 "    TagSetPrefixView:a.{'b': 1, 'd': 2}\n"    
 "    >>> tags.subtags('a', as_tagset=True)\n"    
 "    TagSet:{'b': 1, 'd': 2}\n"    
 '\n'    
 '*Method `TagSet.tag(self, tag_name, prefix=None, ontology=None)`*:\n'    
 'Return a `Tag` for `tag_name`, or `None` if missing.\n'    
 '\n'    
 'Parameters:\n'    
 '* `tag_name`: the name of the `Tag` to create\n'    
 '* `prefix`: optional prefix;\n'    
 "  if supplied, prepend `prefix+'.'` to the `Tag` name\n"    
 '* `ontology`: optional ontology for the `Tag`,\n'    
 '  default `self.ontology`\n'    
 '\n'    
 '*Method `TagSet.tag_metadata(self, tag_name, prefix=None, ontology=None, '    
 'convert=None)`*:\n'    
 'Return a list of the metadata for the `Tag` named `tag_name`,\n'    
 'or an empty list if the `Tag` is missing.\n'    
 '\n'    
 '*Property `TagSet.unixtime`*:\n'    
 '`unixtime` property, autosets to `time.time()` if accessed.\n'    
 '\n'    
 '*Method `TagSet.update(self, other=None, *, prefix=None, verbose=None, '    
 '**kw)`*:\n'    
 'Update this `TagSet` from `other`,\n'    
 'a dict of `{name:value}`\n'    
 'or an iterable of `Tag`like or `(name,value)` things.\n'    
 '\n'    
 '## Class `TagSetCriterion`\n'    
 '\n'    
 'A testable criterion for a `TagSet`.\n'    
 '\n'    
 '*`TagSetCriterion.TAG_BASED_TEST_CLASS`*\n'    
 '\n'    
 '*Method `TagSetCriterion.from_any(*a, **kw)`*:\n'    
 'Convert some suitable object `o` into a `TagSetCriterion`.\n'    
 '\n'    
 'Various possibilities for `o` are:\n'    
 '* `TagSetCriterion`: returned unchanged\n'    
 '* `str`: a string tests for the presence\n'    
 '  of a tag with that name and optional value;\n'    
 '* an object with a `.choice` attribute;\n'    
 '  this is taken to be a `TagSetCriterion` ducktype and returned unchanged\n'    
 '* an object with `.name` and `.value` attributes;\n'    
 '  this is taken to be `Tag`-like and a positive test is constructed\n'    
 '* `Tag`: an object with a `.name` and `.value`\n'    
 '  is equivalent to a positive equality `TagBasedTest`\n'    
 '* `(name,value)`: a 2 element sequence\n'    
 '  is equivalent to a positive equality `TagBasedTest`\n'    
 '\n'    
 '*Method `TagSetCriterion.from_arg(*a, **kw)`*:\n'    
 'Prepare a `TagSetCriterion` from the string `arg`\n'    
 'where `arg` is known to be entirely composed of the value,\n'    
 'such as a command line argument.\n'    
 '\n'    
 'This calls the `from_str` method with `fallback_parse` set\n'    
 'to gather then entire tail of the supplied string `arg`.\n'    
 '\n'    
 '*Method `TagSetCriterion.from_str(*a, **kw)`*:\n'    
 'Prepare a `TagSetCriterion` from the string `s`.\n'    
 '\n'    
 '*Method `TagSetCriterion.from_str2(s, offset=0, delim=None, '    
 'fallback_parse=None)`*:\n'    
 'Parse a criterion from `s` at `offset` and return '    
 '`(TagSetCriterion,offset)`.\n'    
 '\n'    
 "This method recognises an optional leading `'!'` or `'-'`\n"    
 'indicating negation of the test,\n'    
 'followed by a criterion recognised by the `.parse` method\n'    
 'of one of the classes in `cls.CRITERION_PARSE_CLASSES`.\n'    
 '\n'    
 "*Method `TagSetCriterion.match_tagged_entity(self, te: 'TagSet') -> bool`*:\n"    
 'Apply this `TagSetCriterion` to a `TagSet`.\n'    
 '\n'    
 '## Class `TagSetPrefixView(cs.lex.FormatableMixin, '    
 'cs.lex.FormatableFormatter, string.Formatter)`\n'    
 '\n'    
 'A view of a `TagSet` via a `prefix`.\n'    
 '\n'    
 'Access to a key `k` accesses the `TagSet`\n'    
 "with the key `prefix+'.'+k`.\n"    
 '\n'    
 'This is a kind of funny hybrid of a `Tag` and a `TagSet`\n'    
 'in that some things such as `__format__`\n'    
 'will format the `Tag` named `prefix` if it exists\n'    
 'in preference to the subtags.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '    >>> tags = TagSet(a=1, b=2)\n'    
 '    >>> tags\n'    
 "    TagSet:{'a': 1, 'b': 2}\n"    
 "    >>> tags['sub.x'] = 3\n"    
 "    >>> tags['sub.y'] = 4\n"    
 '    >>> tags\n'    
 "    TagSet:{'a': 1, 'b': 2, 'sub.x': 3, 'sub.y': 4}\n"    
 '    >>> sub = tags.sub\n'    
 '    >>> sub\n'    
 "    TagSetPrefixView:sub.{'x': 3, 'y': 4}\n"    
 '    >>> sub.z = 5\n'    
 '    >>> sub\n'    
 "    TagSetPrefixView:sub.{'x': 3, 'y': 4, 'z': 5}\n"    
 '    >>> tags\n'    
 "    TagSet:{'a': 1, 'b': 2, 'sub.x': 3, 'sub.y': 4, 'sub.z': 5}\n"    
 '\n'    
 '*Method `TagSetPrefixView.__getattr__(self, attr)`*:\n'    
 'Proxy other attributes through to the `TagSet`.\n'    
 '\n'    
 '*Method `TagSetPrefixView.__setattr__(self, attr, value)`*:\n'    
 'Attribute based `Tag` access.\n'    
 '\n'    
 'If `attr` is in `self.__dict__` then that is updated,\n'    
 'supporting "normal" attributes set on the instance.\n'    
 'Otherwise the `Tag` named `attr` is set to `value`.\n'    
 '\n'    
 'The `__init__` methods of subclasses should do something like this\n'    
 '(from `TagSet.__init__`)\n'    
 'to set up the ordinary instance attributes\n'    
 'which are not to be treated as `Tag`s:\n'    
 '\n'    
 '    self.__dict__.update(id=_id, ontology=_ontology, modified=False)\n'    
 '\n'    
 '*Method `TagSetPrefixView.get_format_attribute(self, attr)`*:\n'    
 'Fetch a formatting attribute from the proxied object.\n'    
 '\n'    
 '*Method `TagSetPrefixView.items(self)`*:\n'    
 'Return an iterable of the items (`Tag` name, `Tag`).\n'    
 '\n'    
 '*Method `TagSetPrefixView.keys(self)`*:\n'    
 'The keys of the subtags.\n'    
 '\n'    
 '*Property `TagSetPrefixView.ontology`*:\n'    
 'The ontology of the references `TagSet`.\n'    
 '\n'    
 '*Method `TagSetPrefixView.subtags(self, subprefix)`*:\n'    
 'Return a deeper view of the `TagSet`.\n'    
 '\n'    
 '*Property `TagSetPrefixView.tag`*:\n'    
 'The `Tag` for the prefix, or `None` if there is no such `Tag`.\n'    
 '\n'    
 '*Property `TagSetPrefixView.value`*:\n'    
 'Return the `Tag` value for the prefix, or `None` if there is no such `Tag`.\n'    
 '\n'    
 '*Method `TagSetPrefixView.values(self)`*:\n'    
 'Return an iterable of the values (`Tag`s).\n'    
 '\n'    
 '## Class `TagSetsSubdomain(cs.obj.SingletonMixin, '    
 'cs.mappings.PrefixedMappingProxy, cs.mappings.RemappedMappingProxy)`\n'    
 '\n'    
 'A view into a `BaseTagSets` for keys commencing with a prefix\n'    
 "being the subdomain plus a dot (`'.'`).\n"    
 '\n'    
 '*Property `TagSetsSubdomain.TAGGED_ENTITY_FACTORY`*:\n'    
 'The entity factory comes from the parent collection.\n'    
 '\n'    
 '## Class `TagsOntology(cs.obj.SingletonMixin, BaseTagSets, '    
 'cs.resources.MultiOpenMixin, cs.context.ContextManagerMixin, '    
 'collections.abc.MutableMapping, collections.abc.Mapping, '    
 'collections.abc.Collection, collections.abc.Sized, collections.abc.Iterable, '    
 'collections.abc.Container)`\n'    
 '\n'    
 'An ontology for tag names.\n'    
 'This is based around a mapping of names\n'    
 'to ontological information expressed as a `TagSet`.\n'    
 '\n'    
 "Normally an object's tags are not a self contained repository of all the "    
 'information;\n'    
 'instead a tag just names some information.\n'    
 '\n'    
 'As a example, consider the tag `colour=blue`.\n'    
 'Meta information about `blue` is obtained via the ontology,\n'    
 'which has an entry for the colour `blue`.\n'    
 'We adopt the convention that the type is just the tag name,\n'    
 'so we obtain the metadata by calling `ontology.metadata(tag)`\n'    
 'or alternatively `ontology.metadata(tag.name,tag.value)`\n'    
 'being the type name and value respectively.\n'    
 '\n'    
 'The ontology itself is based around `TagSets` and effectively the call\n'    
 "`ontology.metadata('colour','blue')`\n"    
 'would look up the `TagSet` named `colour.blue` in the underlying `Tagsets`.\n'    
 '\n'    
 'For a self contained dataset this means that it can be its own ontology.\n'    
 'For tags associated with arbitrary objects\n'    
 'such as the filesystem tags maintained by `cs.fstags`\n'    
 'the ontology would be a separate tags collection stored in a central place.\n'    
 '\n'    
 'There are two main categories of entries in an ontology:\n'    
 '* metadata: other entries named *typename*`.`*value_key*\n'    
 '  contains a `TagSet` holding metadata for a value of type *typename*\n'    
 '  whose value is mapped to *value_key*\n'    
 '* types: an optional entry named `type.`*typename* contains a `TagSet`\n'    
 '  describing the type named *typename*;\n'    
 '  really this is just more metadata where the "type name" is `type`\n'    
 '\n'    
 'Metadata are `TagSets` instances describing particular values of a type.\n'    
 'For example, some metadata for the `Tag` `colour="blue"`:\n'    
 '\n'    
 '    colour.blue url="https://en.wikipedia.org/wiki/Blue" '    
 'wavelengths="450nm-495nm"\n'    
 '\n'    
 'Some metadata associated with the `Tag` `actor="Scarlett Johansson"`:\n'    
 '\n'    
 '    actor.scarlett_johansson role=["Black Widow (Marvel)"]\n'    
 '    character.marvel.black_widow fullname=["Natasha Romanov"]\n'    
 '\n'    
 'The tag values are lists above because an actor might play many roles, etc.\n'    
 '\n'    
 "There's a convention for converting human descriptions\n"    
 'such as the role string `"Black Widow (Marvel)"` to its metadata.\n'    
 '* the value `"Black Widow (Marvel)"` if converted to a key\n'    
 '  by the ontology method `value_to_tag_name`;\n'    
 '  it moves a bracket suffix such as `(Marvel)` to the front as a prefix\n'    
 '  `marvel.` and downcases the rest of the string and turns spaces into '    
 'underscores.\n'    
 '  This yields the value key `marvel.black_widow`.\n'    
 '* the type is `role`, so the ontology entry for the metadata\n'    
 '  is `role.marvel.black_widow`\n'    
 '\n'    
 'this requires type information about a `role`.\n'    
 'Here are some type definitions supporting the above metadata:\n'    
 '\n'    
 '    type.person type=str description="A person."\n'    
 '    type.actor type=person description="An actor\'s stage name."\n'    
 '    type.character type=str description="A person in a story."\n'    
 '    type.role type_name=character description="A character role in a '    
 'performance."\n'    
 '    type.cast type=dict key_type=actor member_type=role description="Cast '    
 'members and their roles."\n'    
 '\n'    
 'The basic types have their Python names: `int`, `float`, `str`, `list`,\n'    
 '`dict`, `date`, `datetime`.\n'    
 'You can define subtypes of these for your own purposes\n'    
 'as illustrated above.\n'    
 '\n'    
 'For example:\n'    
 '\n'    
 '    type.colour type=str description="A hue."\n'    
 '\n'    
 'which subclasses `str`.\n'    
 '\n'    
 'Subtypes of `list` include a `member_type`\n'    
 'specifying the type for members of a `Tag` value:\n'    
 '\n'    
 '    type.scene type=list member_type=str description="A movie scene."\n'    
 '\n'    
 'Subtypes of `dict` include a `key_type` and a `member_type`\n'    
 'specifying the type for keys and members of a `Tag` value:\n'    
 '\n'    
 'Accessing type data and metadata:\n'    
 '\n'    
 'A `TagSet` may have a reference to a `TagsOntology` as `.ontology`\n'    
 'and so also do any of its `Tag`s.\n'    
 '\n'    
 '*Method `TagsOntology.__bool__(self)`*:\n'    
 'Support easy `ontology or some_default` tests,\n'    
 'since ontologies are broadly optional.\n'    
 '\n'    
 '*Method `TagsOntology.__delitem__(self, name)`*:\n'    
 'Delete the entity named `name`.\n'    
 '\n'    
 '*Method `TagsOntology.__getitem__(self, name)`*:\n'    
 'Fetch `tags` for the entity named `name`.\n'    
 '\n'    
 '*Method `TagsOntology.__setitem__(self, name, tags)`*:\n'    
 'Apply `tags` to the entity named `name`.\n'    
 '\n'    
 '*Method `TagsOntology.add_tagsets(self, *a, **kw)`*:\n'    
 'Insert a `_TagsOntology_SubTagSets` at `index`\n'    
 'in the list of `_TagsOntology_SubTagSets`es.\n'    
 '\n'    
 'The new `_TagsOntology_SubTagSets` instance is initialised\n'    
 'from the supplied `tagsets`, `match`, `unmatch` parameters.\n'    
 '\n'    
 '*Method `TagsOntology.as_dict(self)`*:\n'    
 'Return a `dict` containing a mapping of entry names to their `TagSet`s.\n'    
 '\n'    
 '*Method `TagsOntology.basetype(self, typename)`*:\n'    
 'Infer the base type name from a type name.\n'    
 "The default type is `'str'`,\n"    
 'but any type which resolves to one in `self.BASE_TYPES`\n'    
 'may be returned.\n'    
 '\n'    
 '*Method `TagsOntology.by_type(self, type_name, with_tagsets=False)`*:\n'    
 'Yield keys or (key,tagset) of type `type_name`\n'    
 'i.e. all keys commencing with *type_name*`.`.\n'    
 '\n'    
 '*Method `TagsOntology.convert_tag(self, tag)`*:\n'    
 "Convert a `Tag`'s value accord to the ontology.\n"    
 'Return a new `Tag` with the converted value\n'    
 'or the original `Tag` unchanged.\n'    
 '\n'    
 'This is primarily aimed at things like regexp based autotagging,\n'    
 'where the matches are all strings\n'    
 'but various fields have special types,\n'    
 'commonly `int`s or `date`s.\n'    
 '\n'    
 '*Method `TagsOntology.edit_indices(self, *a, **kw)`*:\n'    
 'Edit the entries specified by indices.\n'    
 'Return `TagSet`s for the entries which were changed.\n'    
 '\n'    
 '*Method `TagsOntology.from_match(*a, **kw)`*:\n'    
 'Initialise a `SubTagSets` from `tagsets`, `match` and optional `unmatch`.\n'    
 '\n'    
 'Parameters:\n'    
 '* `tagsets`: a `TagSets` holding ontology information\n'    
 '* `match`: a match function used to choose entries based on a type name\n'    
 '* `unmatch`: an optional reverse for `match`, accepting a subtype\n'    
 '  name and returning its public name\n'    
 '\n'    
 'If `match` is `None`\n'    
 'then `tagsets` will always be chosen if no prior entry matched.\n'    
 '\n'    
 'Otherwise, `match` is resolved to a function `match-func(type_name)`\n'    
 'which returns a subtype name on a match and a false value on no match.\n'    
 '\n'    
 'If `match` is a callable it is used as `match_func` directly.\n'    
 '\n'    
 'if `match` is a list, tuple or set\n'    
 'then this method calls itself with `(tagsets,submatch)`\n'    
 'for each member `submatch` if `match`.\n'    
 '\n'    
 'If `match` is a `str`,\n'    
 "if it ends in a dot '.', dash '-' or underscore '_'\n"    
 'then it is considered a prefix of `type_name` and the returned\n'    
 'subtype name is the text from `type_name` after the prefix\n'    
 'othwerwise it is considered a full match for the `type_name`\n'    
 'and the returns subtype name is `type_name` unchanged.\n'    
 'The `match` string is a simplistic shell style glob\n'    
 'supporting `*` but not `?` or `[`*seq*`]`.\n'    
 '\n'    
 'The value of `unmatch` is constrained by `match`.\n'    
 'If `match` is `None`, `unmatch` must also be `None`;\n'    
 'the type name is used unchanged.\n'    
 'If `match` is callable`, `unmatch` must also be callable;\n'    
 'it is expected to reverse `match`.\n'    
 '\n'    
 'Examples:\n'    
 '\n'    
 '    >>> from cs.sqltags import SQLTags\n'    
 '    >>> from os.path import expanduser as u\n'    
 '    >>> # an initial empty ontology with a default in memory mapping\n'    
 '    >>> ont = TagsOntology()\n'    
 '    >>> # divert the types actor, role and series to my media ontology\n'    
 '    >>> ont.add_tagsets(\n'    
 "    ...     SQLTags(u('~/var/media-ontology.sqlite')),\n"    
 "    ...     ['actor', 'role', 'series'])\n"    
 '    >>> # divert type "musicbrainz.recording" to mbdb.sqlite\n'    
 '    >>> # mapping to the type "recording"\n'    
 "    >>> ont.add_tagsets(SQLTags(u('~/.cache/mbdb.sqlite')), 'musicbrainz.')\n"    
 '    >>> # divert type "tvdb.actor" to tvdb.sqlite\n'    
 '    >>> # mapping to the type "actor"\n'    
 "    >>> ont.add_tagsets(SQLTags(u('~/.cache/tvdb.sqlite')), 'tvdb.')\n"    
 '\n'    
 '*Method `TagsOntology.get(self, name, default=None)`*:\n'    
 'Fetch the entity named `name` or `default`.\n'    
 '\n'    
 '*Method `TagsOntology.items(self)`*:\n'    
 'Yield `(entity_name,tags)` for all the items in each subtagsets.\n'    
 '\n'    
 '*Method `TagsOntology.keys(self)`*:\n'    
 'Yield entity names for all the entities.\n'    
 '\n'    
 '*Method `TagsOntology.metadata(self, name, value=None, *a, **kw)`*:\n'    
 'Return the metadata `TagSet` for `type_name` and `value`.\n'    
 "This implements the mapping between a type's value and its semantics.\n"    
 '\n'    
 'The optional parameter `convert`\n'    
 'may specify a function to use to convert `value` to a tag name component\n'    
 'to be used in place of `self.value_to_tag_name` (the default).\n'    
 '\n'    
 'For example, if a `TagSet` had a list of characters such as:\n'    
 '\n'    
 '    character=["Captain America (Marvel)","Black Widow (Marvel)"]\n'    
 '\n'    
 'then these values could be converted to the dotted identifiers\n'    
 '`character.marvel.captain_america`\n'    
 'and `character.marvel.black_widow` respectively,\n'    
 'ready for lookup in the ontology\n'    
 'to obtain the "metadata" `TagSet` for each specific value.\n'    
 '\n'    
 '*Method `TagsOntology.startup_shutdown(self)`*:\n'    
 'Open all the sub`TagSets` and close on exit.\n'    
 '\n'    
 '*Method `TagsOntology.subtype_name(self, type_name)`*:\n'    
 'Return the type name for use within `self.tagsets` from `type_name`.\n'    
 'Returns `None` if this is not a supported `type_name`.\n'    
 '\n'    
 '*Method `TagsOntology.type_name(self, subtype_name)`*:\n'    
 'Return the external type name from the internal `subtype_name`\n'    
 'which is used within `self.tagsets`.\n'    
 '\n'    
 '*Method `TagsOntology.type_names(self)`*:\n'    
 'Return defined type names i.e. all entries starting `type.`.\n'    
 '\n'    
 '*Method `TagsOntology.type_values(self, type_name, value_tag_name=None)`*:\n'    
 'Yield the various defined values for `type_name`.\n'    
 'This is useful for types with enumerated metadata entries.\n'    
 '\n'    
 'For example, if metadata entries exist as `foo.bah` and `foo.baz`\n'    
 "for the `type_name` `'foo'`\n"    
 "then this yields `'bah'` and `'baz'`.`\n"    
 '\n'    
 'Note that this looks for a `Tag` for the value,\n'    
 'falling back to the entry suffix if the tag is not present.\n'    
 'That tag is normally named `value`\n'    
 '(from DEFAULT_VALUE_TAG_NAME)\n'    
 'but may be overridden by the `value_tag_name` parameter.\n'    
 'Also note that normally it is desireable that the value\n'    
 'convert to the suffix via the `value_to_tag_name` method\n'    
 'so that the metadata entry can be located from the value.\n'    
 '\n'    
 '*Method `TagsOntology.typedef(self, type_name)`*:\n'    
 'Return the `TagSet` defining the type named `type_name`.\n'    
 '\n'    
 '*Method `TagsOntology.types(self)`*:\n'    
 'Generator yielding defined type names and their defining `TagSet`.\n'    
 '\n'    
 '*Method `TagsOntology.value_to_tag_name(*a, **kw)`*:\n'    
 'Convert a tag value to a tagnamelike dotted identifierish string\n'    
 'for use in ontology lookup.\n'    
 'Raises `ValueError` for unconvertable values.\n'    
 '\n'    
 'We are allowing dashes in the result (UUIDs, MusicBrainz discids, etc).\n'    
 '\n'    
 '`int`s are converted to `str`.\n'    
 '\n'    
 'Strings are converted as follows:\n'    
 '* a trailing `(.*)` is turned into a prefix with a dot,\n'    
 '  for example `"Captain America (Marvel)"`\n'    
 '  becomes `"Marvel.Captain America"`.\n'    
 '* the string is split into words (nonwhitespace),\n'    
 '  lowercased and joined with underscores,\n'    
 '  for example `"Marvel.Captain America"`\n'    
 '  becomes `"marvel.captain_america"`.\n'    
 '\n'    
 '## Class `TagsOntologyCommand(cs.cmdutils.BaseCommand)`\n'    
 '\n'    
 'A command line for working with ontology types.\n'    
 '\n'    
 'Command line usage:\n'    
 '\n'    
 '    Usage: tagsontology subcommand [...]\n'    
 '      Subcommands:\n'    
 '        edit [{/name-regexp | entity-name}]\n'    
 '          Edit entities.\n'    
 '          With no arguments, edit all the entities.\n'    
 '          With an argument starting with a slash, edit the entities\n'    
 '          whose names match the regexp.\n'    
 '          Otherwise the argument is expected to be an entity name;\n'    
 '          edit the tags of that entity.\n'    
 '        help [-l] [subcommand-names...]\n'    
 '          Print the full help for the named subcommands,\n'    
 '          or for all subcommands if no names are specified.\n'    
 '          -l  Long help even if no subcommand-names provided.\n'    
 '        meta tag=value\n'    
 '        type\n'    
 '            With no arguments, list the defined types.\n'    
 '          type type_name\n'    
 '            With a type name, print its `Tag`s.\n'    
 '          type type_name edit\n'    
 '            Edit the tags defining a type.\n'    
 '          type type_name edit meta_names_pattern...\n'    
 '            Edit the tags for the metadata names matching the\n'    
 '            meta_names_patterns.\n'    
 '          type type_name list\n'    
 '          type type_name ls\n'    
 '            List the metadata names for this type and their tags.\n'    
 '          type type_name + entity_name [tags...]\n'    
 '            Create type_name.entity_name and apply the tags.\n'    
 '\n'    
 '*Method `TagsOntologyCommand.cmd_edit(self, argv)`*:\n'    
 'Usage: {cmd} [{{/name-regexp | entity-name}}]\n'    
 'Edit entities.\n'    
 'With no arguments, edit all the entities.\n'    
 'With an argument starting with a slash, edit the entities\n'    
 'whose names match the regexp.\n'    
 'Otherwise the argument is expected to be an entity name;\n'    
 'edit the tags of that entity.\n'    
 '\n'    
 '*Method `TagsOntologyCommand.cmd_meta(self, argv)`*:\n'    
 'Usage: {cmd} tag=value\n'    
 '\n'    
 '*Method `TagsOntologyCommand.cmd_type(self, argv)`*:\n'    
 'Usage:\n'    
 '{cmd}\n'    
 '  With no arguments, list the defined types.\n'    
 '{cmd} type_name\n'    
 '  With a type name, print its `Tag`s.\n'    
 '{cmd} type_name edit\n'    
 '  Edit the tags defining a type.\n'    
 '{cmd} type_name edit meta_names_pattern...\n'    
 '  Edit the tags for the metadata names matching the\n'    
 '  meta_names_patterns.\n'    
 '{cmd} type_name list\n'    
 '{cmd} type_name ls\n'    
 '  List the metadata names for this type and their tags.\n'    
 '{cmd} type_name + entity_name [tags...]\n'    
 '  Create type_name.entity_name and apply the tags.\n'    
 '\n'    
 '# Release Log\n'    
 '\n'    
 '\n'    
 '\n'    
 '*Release 20220311*:\n'    
 'Assorted internal changes.\n'    
 '\n'    
 '*Release 20211212*:\n'    
 '* Tag: new fallback_parse parameter for value parsing, default '    
 'get_nonwhite.\n'    
 '* Tag: new from_arg factory with fallback_parse grabbing the whole string '    
 'for command line arguments, thus supporting unquoted strings for ease of '    
 'use.\n'    
 '* TagSetCriterion: new optional fallback_parse parameter and from_arg method '    
 'as for the Tag factories.\n'    
 '* Tag.transcribe_value: accept optional json_options to control the JSON '    
 'encoder, used for human friendly multiline edits in cs.app.tagger.\n'    
 '* Rename edit_many to edit_tagsets for clarity.\n'    
 '* TagsOntology: new type_values method to return values for a type (derived '    
 'from their metadata entries).\n'    
 '* Tag: new alt_values method returning its TagsOntology.type_values.\n'    
 '* (Internal) New _FormatStringTagProxy which proxies a Tag but uses '    
 'str(self.__proxied.value) for __str__ to support format strings.\n'    
 '* (Internal) TagSet.get_value: if arg_name matches a Tag, return a '    
 '_FormatStringTagProxy.\n'    
 '* Tag.__new__: accept (tag_name,value) or (Tag) as initialisation '    
 'parameters.\n'    
 '\n'    
 '*Release 20210913*:\n'    
 '* TagSet.get_value: raise KeyError in strict mode, leave placeholder '    
 'otherwise.\n'    
 '* Other small changes.\n'    
 '\n'    
 '*Release 20210906*:\n'    
 'Many many updates; some semantics have changed.\n'    
 '\n'    
 '*Release 20210428*:\n'    
 'Bugfix TagSet.set: internal in place changes to a complex tag value were not '    
 'noticed, causing TagFile to not update on shutdown.\n'    
 '\n'    
 '*Release 20210420*:\n'    
 '* TagSet: also subclass cs.dateutils.UNIXTimeMixin.\n'    
 '* Various TagSetNamespace updates and bugfixes.\n'    
 '\n'    
 '*Release 20210404*:\n'    
 'Bugfix TagBasedTest.COMPARISON_FUNCS["="]: if cmp_value is None, return true '    
 '(the tag is present).\n'    
 '\n'    
 '*Release 20210306*:\n'    
 '* ExtendedNamespace,TagSetNamespace: move the .[:alpha:]* attribute support '    
 'from ExtendedNamespace to TagSetNamespace because it requires Tags.\n'    
 '* TagSetNamespace.__getattr__: new _i, _s, _f suffixes to return int, str or '    
 'float tag values (or None); fold _lc in with these.\n'    
 '* Pull most of `TaggedEntity` out into `TaggedEntityMixin` for reuse by '    
 'domain specific tagged entities.\n'    
 '* TaggedEntity: new .set and .discard methods.\n'    
 '* TaggedEntity: new as_editable_line, from_editable_line, edit and '    
 'edit_entities methods to support editing entities using a text editor.\n'    
 '* ontologies: type entries are now prefixed with "type." and metadata '    
 'entries are prefixed with "meta."; provide a worked ontology example in the '    
 'introduction and improve related docstrings.\n'    
 '* TagsOntology: new .types(), .types_names(), .meta(type_name,value), '    
 '.meta_names() methods.\n'    
 '* TagsOntology.__getitem__: create missing TagSets on demand.\n'    
 '* New TagsOntologyCommand, initially with a "type [type_name [{edit|list}]]" '    
 'subcommand, ready for use as the cmd_ont subcommand of other tag related '    
 'commands.\n'    
 '* TagSet: support initialisation like a dict including keywords, and move '    
 'the `ontology` parameter to `_onotology`.\n'    
 '* TagSet: include AttrableMappingMixin to enable attribute access to values '    
 'when there is no conflict with normal methods.\n'    
 '* UUID encode/decode support.\n'    
 '* Honour $TAGSET_EDITOR or $EDITOR as preferred interactive editor for '    
 'tags.\n'    
 '* New TagSet.subtags(prefix) to extract a subset of the tags.\n'    
 '* TagsOntology.value_metadata: new optional convert parameter to override '    
 'the default "convert human friendly name" algorithm, particularly to pass '    
 'convert=str to things which are already the basic id.\n'    
 '* Rename TaggedEntity to TagSet.\n'    
 '* Rename TaggedEntities to TagSets.\n'    
 '* TagSet: new csvrow and from_csvrow methods imported from obsolete '    
 'TaggedEntityMixin class.\n'    
 '* Move BaseTagFile from cs.fstags to TagFile in cs.tagset.\n'    
 '* TagSet: support access to the tag "c.x" via attributes provided there is '    
 'no "c" tag in the way.\n'    
 '* TagSet.unixtime: implement the autoset-to-now semantics.\n'    
 '* New as_timestamp(): convert date, datetime, int or float to a UNIX '    
 'timestamp.\n'    
 '* Assorted docstring updates and bugfixes.\n'    
 '\n'    
 '*Release 20200716*:\n'    
 '* Update for changed cs.obj.SingletonMixin API.\n'    
 '* Pull in TaggedEntity from cs.sqltags and add the .csvrow property and the '    
 '.from_csvrow factory.\n'    
 '\n'    
 '*Release 20200521.1*:\n'    
 'Fix DISTINFO.install_requires, drop debug import.\n'    
 '\n'    
 '*Release 20200521*:\n'    
 '* New ValueDetail and KeyValueDetail classes for returning ontology '    
 'information; TagInfo.detail now returns a ValueDetail for scalar types, a '    
 'list of ValueDetails for sequence types and a list of KeyValueDetails for '    
 'mapping types; drop various TagInfo mapping/iterable style methods, too '    
 'confusing to use.\n'    
 '* Plumb ontology parameter throughout, always optional.\n'    
 '* Drop TypedTag, Tags now use ontologies for this.\n'    
 '* New TagsCommandMixin to support BaseCommands which manipulate Tags.\n'    
 '* Many improvements and bugfixes.\n'    
 '\n'    
 '*Release 20200318*:\n'    
 '* *Note that the TagsOntology stuff is in flux and totally alpha.*\n'    
 '* Tag.prefix_name factory returning a new tag if prefix is not empty, '    
 'ptherwise self.\n'    
 '* TagSet.update: accept an optional prefix for inserting "foreign" tags with '    
 'a distinguishing name prefix.\n'    
 '* Tag.as_json: turn sets and tuples into lists for encoding.\n'    
 '* Backport for Python < 3.7 (no fromisoformat functions).\n'    
 '* TagSet: drop unused and illplaced .titleify, .episode_title and .title '    
 'methods.\n'    
 '* TagSet: remove "defaults", unused.\n'    
 '* Make TagSet a direct subclass of dict, adjust uses of .update etc.\n'    
 '* New ExtendedNamespace class which is a SimpleNamespace with some inferred '    
 'attributes and a partial mapping API (keys and __getitem__).\n'    
 '* New TagSet.ns() returning the Tags as an ExtendedNamespace, which doubles '    
 'as a mapping for str.format_map; TagSet.format_kwargs is now an alias for '    
 'this.\n'    
 '* New Tag.from_string factory to parse a str into a Tag.\n'    
 '* New TagsOntology and TypedTag classes to provide type and value-detail '    
 'information; very very alpha and subject to change.\n'    
 '\n'    
 '*Release 20200229.1*:\n'    
 'Initial release: pull TagSet, Tag, TagChoice from cs.fstags for independent '    
 'use.'),
  install_requires = ['cs.cmdutils>=20210404', 'cs.dateutils', 'cs.deco', 'cs.edit', 'cs.fileutils', 'cs.lex', 'cs.logutils', 'cs.mappings', 'cs.obj>=20200716', 'cs.pfx', 'cs.py3', 'cs.resources', 'cs.threads', 'icontract', 'typeguard'],
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)'],
  keywords = ['python3'],
  license = 'GNU General Public License v3 or later (GPLv3+)',
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.tagset'],
)
