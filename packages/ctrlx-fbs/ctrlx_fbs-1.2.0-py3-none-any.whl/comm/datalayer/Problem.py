# automatically generated by the FlatBuffers compiler, do not modify

# namespace: datalayer

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Problem(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Problem()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsProblem(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Problem
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Problem
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Problem
    def Title(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Problem
    def Status(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Problem
    def Detail(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Problem
    def Instance(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Problem
    def MainDiagnosisCode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Problem
    def DetailedDiagnosisCode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Problem
    def DynamicDescription(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Problem
    def Severity(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Problem
    def Links(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Problem
    def LinksLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Problem
    def LinksIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

    # Problem
    def Entity(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def ProblemStart(builder): builder.StartObject(11)
def Start(builder):
    return ProblemStart(builder)
def ProblemAddType(builder, type): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)
def AddType(builder, type):
    return ProblemAddType(builder, type)
def ProblemAddTitle(builder, title): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(title), 0)
def AddTitle(builder, title):
    return ProblemAddTitle(builder, title)
def ProblemAddStatus(builder, status): builder.PrependInt32Slot(2, status, 0)
def AddStatus(builder, status):
    return ProblemAddStatus(builder, status)
def ProblemAddDetail(builder, detail): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(detail), 0)
def AddDetail(builder, detail):
    return ProblemAddDetail(builder, detail)
def ProblemAddInstance(builder, instance): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(instance), 0)
def AddInstance(builder, instance):
    return ProblemAddInstance(builder, instance)
def ProblemAddMainDiagnosisCode(builder, mainDiagnosisCode): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(mainDiagnosisCode), 0)
def AddMainDiagnosisCode(builder, mainDiagnosisCode):
    return ProblemAddMainDiagnosisCode(builder, mainDiagnosisCode)
def ProblemAddDetailedDiagnosisCode(builder, detailedDiagnosisCode): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(detailedDiagnosisCode), 0)
def AddDetailedDiagnosisCode(builder, detailedDiagnosisCode):
    return ProblemAddDetailedDiagnosisCode(builder, detailedDiagnosisCode)
def ProblemAddDynamicDescription(builder, dynamicDescription): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(dynamicDescription), 0)
def AddDynamicDescription(builder, dynamicDescription):
    return ProblemAddDynamicDescription(builder, dynamicDescription)
def ProblemAddSeverity(builder, severity): builder.PrependInt8Slot(8, severity, 0)
def AddSeverity(builder, severity):
    return ProblemAddSeverity(builder, severity)
def ProblemAddLinks(builder, links): builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(links), 0)
def AddLinks(builder, links):
    return ProblemAddLinks(builder, links)
def ProblemStartLinksVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartLinksVector(builder, numElems):
    return ProblemStartLinksVector(builder, numElems)
def ProblemAddEntity(builder, entity): builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(entity), 0)
def AddEntity(builder, entity):
    return ProblemAddEntity(builder, entity)
def ProblemEnd(builder): return builder.EndObject()
def End(builder):
    return ProblemEnd(builder)
try:
    from typing import List
except:
    pass

class ProblemT(object):

    # ProblemT
    def __init__(self):
        self.type = None  # type: str
        self.title = None  # type: str
        self.status = 0  # type: int
        self.detail = None  # type: str
        self.instance = None  # type: str
        self.mainDiagnosisCode = None  # type: str
        self.detailedDiagnosisCode = None  # type: str
        self.dynamicDescription = None  # type: str
        self.severity = 0  # type: int
        self.links = None  # type: List[str]
        self.entity = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        problem = Problem()
        problem.Init(buf, pos)
        return cls.InitFromObj(problem)

    @classmethod
    def InitFromObj(cls, problem):
        x = ProblemT()
        x._UnPack(problem)
        return x

    # ProblemT
    def _UnPack(self, problem):
        if problem is None:
            return
        self.type = problem.Type()
        self.title = problem.Title()
        self.status = problem.Status()
        self.detail = problem.Detail()
        self.instance = problem.Instance()
        self.mainDiagnosisCode = problem.MainDiagnosisCode()
        self.detailedDiagnosisCode = problem.DetailedDiagnosisCode()
        self.dynamicDescription = problem.DynamicDescription()
        self.severity = problem.Severity()
        if not problem.LinksIsNone():
            self.links = []
            for i in range(problem.LinksLength()):
                self.links.append(problem.Links(i))
        self.entity = problem.Entity()

    # ProblemT
    def Pack(self, builder):
        if self.type is not None:
            type = builder.CreateString(self.type)
        if self.title is not None:
            title = builder.CreateString(self.title)
        if self.detail is not None:
            detail = builder.CreateString(self.detail)
        if self.instance is not None:
            instance = builder.CreateString(self.instance)
        if self.mainDiagnosisCode is not None:
            mainDiagnosisCode = builder.CreateString(self.mainDiagnosisCode)
        if self.detailedDiagnosisCode is not None:
            detailedDiagnosisCode = builder.CreateString(self.detailedDiagnosisCode)
        if self.dynamicDescription is not None:
            dynamicDescription = builder.CreateString(self.dynamicDescription)
        if self.links is not None:
            linkslist = []
            for i in range(len(self.links)):
                linkslist.append(builder.CreateString(self.links[i]))
            ProblemStartLinksVector(builder, len(self.links))
            for i in reversed(range(len(self.links))):
                builder.PrependUOffsetTRelative(linkslist[i])
            links = builder.EndVector()
        if self.entity is not None:
            entity = builder.CreateString(self.entity)
        ProblemStart(builder)
        if self.type is not None:
            ProblemAddType(builder, type)
        if self.title is not None:
            ProblemAddTitle(builder, title)
        ProblemAddStatus(builder, self.status)
        if self.detail is not None:
            ProblemAddDetail(builder, detail)
        if self.instance is not None:
            ProblemAddInstance(builder, instance)
        if self.mainDiagnosisCode is not None:
            ProblemAddMainDiagnosisCode(builder, mainDiagnosisCode)
        if self.detailedDiagnosisCode is not None:
            ProblemAddDetailedDiagnosisCode(builder, detailedDiagnosisCode)
        if self.dynamicDescription is not None:
            ProblemAddDynamicDescription(builder, dynamicDescription)
        ProblemAddSeverity(builder, self.severity)
        if self.links is not None:
            ProblemAddLinks(builder, links)
        if self.entity is not None:
            ProblemAddEntity(builder, entity)
        problem = ProblemEnd(builder)
        return problem
